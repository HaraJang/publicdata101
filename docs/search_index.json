[["index.html", "공공데이터 분석 101 챕터 1 모두를 위한 공공데이터 1.1 서론 1.2 이 책의 목적지 1.3 공공데이터란 무엇일까? 1.4 공공데이터를 분석 하는 이유 1.5 공공데이터 활용사례 1.6 무엇을 배우게 될까? 1.7 R을 사용하는 이유", " 공공데이터 분석 101 Project Statgarten 2023-10-23 챕터 1 모두를 위한 공공데이터 *본 이미지는 DALL·E 3를 통해 생성되었습니다. 1.1 서론 우리는 빅데이터와 인공지능의 시대를 살고 있습니다. 인류는 기술의 발전과 함께 수많은 데이터를 수집하고 보유하게 되었습니다. 이러한 데이터는 공공부문에서도 예외는 아닙니다. 정부 기관, 공공기관 및 비영리 단체는 국민의 생활에 영향을 미치는 다양한 분야에서 데이터를 수집하고 보유하고 있습니다. 그러나 그저 쌓여 있기만 한 데이터는 그 자체로는 가치가 없습니다. 죽어있는 데이터를 실제 세상에서 살아 움직이는 데이터로 만드는 일이 필요합니다. 하지만 공공데이터 분석은 그 자체로 쉬운 작업은 아닙니다. 데이터의 복잡성, 다양성, 크기 등이 도전 요인이 될 수 있습니다. 또한, 데이터의 개인정보 보호와 관련된 윤리적인 문제도 고려되어야 합니다. 따라서, 이 분야에서 활동하고자 하는 사람들은 데이터 분석 기술과 도구에 대한 이해뿐만 아니라 윤리적인 측면과 법적인 요구 사항에 대한 이해도 필요합니다. 본 교재에서는 공공데이터 분석에 대한 입문 지식을 제공하고, 분석을 위해 필요한 핵심 개념, 기술, 도구 등을 살펴볼 것입니다. 또한 공공데이터를 통한 의사결정과 문제해결에 대한 이해를 높이고자 합니다. 1.2 이 책의 목적지 이 책의 목적은 “데이터를 통한 보다 나은 의사결정”을 연습하는 것 입니다. 물론 데이터를 분석하며 세상의 비밀을 하나씩 찾아가는 행위 자체에서 오는 순수한 즐거움도 있고 가설을 확인하려는 목적도 있겠지만, 데이터는 결국 좋은 의사결정이라는 열매를 맺었을 때 가장 빛이 납니다. 작게는 오후에 비가 올거라는 예보 데이터를 기반으로 오늘 아침 우산을 챙겨나오는 것이나 주식 데이터를 보며 투자할 종목을 결정하는 것부터 국가의 중요한 정책 결정까지, 데이터는 불확실한 상황에서도 결정할 수 있는 용기를 줍니다. 하지만 생각보다 많은 사람들이 데이터에 압도되다 결국 본질을 잃곤 합니다. 달을 보라고 손가락을 들었더니 달은 보지 않고 손가락만 쳐다보고 있기도 합니다. 그럴수록 우리는 이 데이터 여정에서 길을 잃지 않기 위해 언제나 종착점을 주시하고 있어야합니다. 이 책이 결국 향하고자 하는 종착점의 이름은 “데이터에 기반한 좋은 의사결정”입니다. Done is better than perfect – Sheryl Sandberg 이 책의 특징은 매우 얕은 지식입니다. 쓸모 있더라도 어려운 것들을 과감히 들어내려 노력했습니다. 그러니 가벼운 마음으로 시작하셔도 됩니다. 데이터가 소수의 전문가 손에 있을 때에 권력이 되지만, 보다 많은 사람들이 데이터로 생각하고 대화하고 결정하는 데 조금이나마 도움이 되길 바라며 이 책을 씁니다. 코드를 하나하나 따라 적으면 제일 좋겠지만 그저 ‘이런 코드를 넣으면 이런 결과가 나오는구나’ 정도만 생각하면서 읽어도 충분합니다. 완벽하게 하려 우물쭈물 하기 보다는 일단 여기까지 읽었으니 일단 시작해 보는 건 어떨까요? 1.3 공공데이터란 무엇일까? 공공기관은 누구든지 공공데이터를 편리하게 이용할 수 있도록 노력하여야 하며, 이용권의 보편적 확대를 위하여 필요한 조치를 취하여야 한다. – 공공데이터의 제공 및 이용 활성화에 관한 법률 제3조 공공데이터란 정부, 지방자치단체, 공공기관 등이 보유 및 공개하고 있는 데이터를 말합니다. 이는 국민의 세금으로 만들어진 데이터이기 때문에 국민 누구나에게 공개되며 자유롭게 이용할 수 있습니다. 이런 공공데이터는 정부의 투명성과 효율성을 높이는 데에도 도움이 됩니다. 이처럼 정부가 공공데이터를 공개함으로써 국민의 알 권리를 보장하고, 국민의 참여를 유도할 수 있습니다. 또한, 공공데이터를 공개함으로써 정부의 정책 수립과 집행을 투명하게 할 수 있습니다. 공공데이터는 정부와 국민이 함께 발전하는 데 중요한 역할을 합니다. 정부는 공공데이터를 공개함으로써 국민과 소통하고, 국민의 삶의 질을 향상시킬 수 있습니다. 또한, 국민은 공공데이터를 활용함으로써 정부의 정책 수립에 참여하고, 더 나은 사회를 만들 수 있습니다. 1.4 공공데이터를 분석 하는 이유 무엇보다 데이터 비즈니스 생태계에 마중물이 될 수 있습니다. 데이터 비즈니스에서 가장 어려운 점 중에 하나는 양질의 데이터 확보입니다. 데이터 확보하기 위해서는 기본적으로 인력이나 센서같은 장비가 필요합니다. 그리고 인력과 장비에는 많은 비용이 듭니다. 데이터를 정제하고, 인사이트를 찾아내고 문제를 해결하는건 데이터가 확보 이후에나 가능한 일들입니다. 하지만 우리는 대한민국 국민으로 태어났다는 이유만으로 정부나 공공기관이 인력과 자원을 들여 구축한 이 공공데이터를 아무런 비용 없이 사용할 수 있습니다. 공공데이터포털에 접속해보면 2023년 5월 기준으로 현재 1,016개 기관에서 58,398건의 파일데이터, 10,884건의 API 및 9,350건의 표준데이터를 제공하고 있습니다. (물론 엉망진창인 데이터도 종종 존재하지만) 대부분의 공공데이터는 정확하고 신뢰할 수 있습니다. 1.5 공공데이터 활용사례 공공데이터포털 활용사례에 접속하면 다양한 공공데이터 활용사례를 볼 수 있습니다. 전국의 버스정보를 실시간으로 제공하는 모바일 애플리케이션부터 날씨, 투자, 부동산, 교통, 환경, 병원, 의료, 교육, 문화, 관광, 미세먼지, 공기질, 식품, 안전, 범죄 등 우리의 실생활이 연결된 대부분의 분야에서 공공데이터를 활용한 서비스들이 존재합니다. 1.6 무엇을 배우게 될까? 우리는 크게 3가지를 배울 것입니다. 공공데이터의 이해: 공공데이터는 어떻게 개방되고, 어떤 데이터들이 어디에 위치하고 있는지, 데이터는 어떤 형태로 저장되어 있는지를 알아볼 것입니다. 분석언어(R)의 이해: 획득한 데이터를 탐색하고 분석하고 가공하는 방법에 대해 배울 것입니다. 본질적으로 데이터 분석은 인간의 사고를 통한 행위입니다. 특별한 툴이 우리의 사고를 대신해 줄 순 없지만, 보다 쉽게 만들어 줄 수는 있습니다. 데이터로 문제 해결하기: 실제 공공데이터 활용 프로젝트를 함께 수행해보며, 데이터 기반의 문제해결에 대해 연습해 보겠습니다. 데이터와 AI만으로 우리 사회의 모든 문제를 해결할 순 없겠지만, 데이터는 길을 알려줄 것입니다. 1.7 R을 사용하는 이유 데이터 분석을 위해서는 어떤 툴이나 언어를 사용해야 할까요? 결론부터 이야기 하자면 시작하는 단계에서는 어떤 것이든 상관이 없습니다. 현실의 문제는 특정한 언어나 도구만으로 풀리지도 않을 뿐더러 모로가도 서울만 가면 된다고 일단 재밌고 꾸준히 할 수 있는게 더 중요합니다. 실제 데이터 분석의 슈퍼스타인 네이트실버가 만든 페코타(메이저리그 성적 예측 시스템)라던지 대선예측시스템은 아주 어려운 프로그래밍이 아닌 엑셀로 만들어 졌다고 합니다. 많은 사람들이 사용하는 Excel과 Google Spread Sheet과 같은 간단한(?) 툴 부터 SAS, SPSS 같은 상용 툴, python이나 julia 같은 언어들이 있지만 우리는 R을 사용할 것입니다. R은 통계 분석과 데이터에 특화된 언어입니다. 통계 및 머신러닝을 쉽게 만들어주는 여러 라이브러리를 제공하며, 데이터 분석 및 시각화를 위한 다양한 패키지들이 제공됩니다. R은 회귀분석, 시계열 분석, 다변량 분석, 생존 분석, 클러스터링 등 다양한 통계 모델링 기법을 지원하는데 이는 통계학이나 사회과학, 의학, 자연과학과 같은 다양한 분야의 연구에서 폭넓게 사용됩니다. 특히 R은 통계학과 데이터 과학자, 많은 학계와 연구 커뮤니티에서 널리 사용됩니다. R은 통계적인 기법과 분석 방법에 대한 최신 연구에 대한 업데이트가 빠르며, 통계학자와 데이터 과학자들이 개발한 패키지와 코드를 공유하고 사용할 수 있습니다. "],["data.html", "챕터 2 공공데이터 이해 2.1 공공데이터 확보하기 2.2 공공데이터 분쟁조정 2.3 공공데이터 이용범위 2.4 파일데이터와 API", " 챕터 2 공공데이터 이해 2.1 공공데이터 확보하기 대부분의 공공데이터는 공공데이터포탈에서 제공됩니다. 포털(공공데이터포털)이란 각 공공기관이 보유하고 있는 공공데이터를 하나로 통합 관리하는 창구 역할을 합니다. 국민에게 개방할 공공데이터가 모두 모여 있는 공간으로 누구나 공공데이터포털을 이용할 수 있습니다. 만약 개방된 공공데이터 외에 목록에 포함되지 않은 공공데이터가 필요할 경우, 공공데이터법 27조에 의해 추가 개방을 신청할 수 있습니다. 해당기관은 요청을 받고 10일 이내에 공공데이터 제공 여부를 결정한 뒤 신청인에게 통보해야 합니다. 공공데이터 신청이 반려되는 경우, 그에 대한 이유를 통보해야 하며 분쟁조정 신청으로 한 번 더 공공데이터 요청이 가능합니다. 2.2 공공데이터 분쟁조정 분쟁조정이란 공공데이터의 제공거부 또는 제공중단과 관련하여, 국민들이 복잡한 행정소송을 거치지 않고 간단한 분쟁조정 절차만으로 데이터를 이용할 수 있도록 지원하는 제도입니다. 공공데이터의 제공거부 또는 제공중단 처분을 받은 날로부터 60일 이내에 공공데이터 포털이나 공공데이터제공분쟁조정위원회 홈페이지에서 신청할 수 있으며, 위원회 이메일 또는 팩스를 통해 분쟁조정신청서를 접수할 수도 있습니다. 공공데이터제공분쟁조정위원회는 공공기관의 제공거부 또는 제공중단처분의 타당성을 심의하고 이와 관련한 분쟁에 대한 조정안을 제공합니다. 분쟁조정신청인과 공공기관이 해당 조정안에 동의하는 경우 조정은 성립하고, 조정의 내용은 재판상 화해와 같은 효력을 가집니다. 분쟁조정이 성립하지 않는 경우, 분쟁조정신청인은 행정소송을 제기할 수 있습니다. 2.3 공공데이터 이용범위 대부분의 공공데이터는 제한없이 사용할 수 있습니다. 다만 일부 데이터에서 제3자 권리가 포함된 공공데이터의 경우 예외사항들이 존재합니다. 따라서 공공데이터 포탈에서는 제3자의 저작물이 포함된 공공데이터를 제공하는 경우 사용권한에 대한 정보를 제공하고 있습니다. 2.4 파일데이터와 API 공공데이터는 크게 파일데이터와 API로 제공이됩니다. 2.4.1 파일데이터 파일데이터는 말 그대로 파일형태로 다운로드 받을 수 있게 제공되는 데이터입니다. 이는 txt, csv, xls, xlsx, xml, json과 같은 문자나 숫자 형태부터 pdf, mp4, jpg, png와 같은 이미지, 영상, 오디오 형태까지 다양한 파일포맷으로 제공이 됩니다. 일반적으로 파일데이터는 다운로드 받아서 사용할 수 있기 때문에, 데이터를 분석하고 시각화하는데 있어서 가장 쉽게 접근할 수 있는 형태입니다. 다만 파일데이터는 일정한 주기로 업데이트가 되지 않기 때문에, 최신 데이터를 이용하고자 할 때는 API를 이용해야 합니다. 2.4.2 Application Program Interface (API) API는 프로그램과 프로그램 사이에서 데이터를 주고 받을 수 있도록 만들어진 인터페이스를 말합니다. API는 일반적으로 웹사이트에서 제공하는 데이터를 프로그램을 통해 가져올 수 있도록 만들어진 인터페이스를 말합니다. API를 이용하면 웹사이트에서 제공하는 데이터를 다운로드 받지 않고도 프로그램을 통해 데이터를 가져올 수 있습니다. API는 일정한 주기로 업데이트가 되기 때문에, 최신 데이터를 이용하고자 할 때는 API를 이용해야 합니다. Agify.io는 그들의 이름을 기반으로 나이를 예측해주는 API입니다. API URL은 다음과 같습니다. https://api.agify.io?name=David url의 맨 마지막 부분에 위치한 name= 다음에 오는 David은 요청하는 이름을 의미합니다. 이는 응답 받기 원하는 다름 이름으로 바꿔 요청할 수 있습니다. 위의 URL을 브라우저에 입력하면 다음과 같은 결과를 얻을 수 있습니다. { &quot;name&quot;: &quot;David&quot;, &quot;age&quot;: 35, &quot;count&quot;: 1120 } 이 API는 다음과 같이 R에서도 사용할 수 있습니다. 아직 R의 사용법에 대해서 자세히 배우지 않았기 때문에 코드를 이해하지 못하더라도 걱정하지 않으셔도 됩니다. 이 코드는 API를 이용해서 데이터를 가져오는 방법을 보여주기 위한 것입니다. library(httr) library(jsonlite) url &lt;- &quot;https://api.agify.io?name=David&quot; response &lt;- GET(url) result &lt;- fromJSON(content(response, &quot;text&quot;)) result ## $count ## [1] 546685 ## ## $name ## [1] &quot;David&quot; ## ## $age ## [1] 61 2.4.3 공공데이터 활용신청 공공데이터를 활용하기 위해서는 먼저 1) 공공데이터포탈에서 API key를 발급받고, 해당 공공데이터 API에 대한 2)활용신청을 해야 합니다. API Key는 활용신청한 공공데이터를 이용하기 위한 인증서 역할을 합니다. API가 외부에 노출되지 않도록 보안에 특별히 유의하세요. 공공데이터를 신청하고 활용하는 자세한 방법에 대해서는 뒤에 다루도록 하겠습니다. 그 전에 우리는 데이터를 분석할 수 있는 언어인 R에 대해서 배울 것입니다. "],["r-에센셜.html", "챕터 3 R 에센셜 3.1 R과 R Studio 설치 3.2 Hello World! 3.3 예쁜 테마는 일할 맛 나게 해주지 3.4 당신의 고민은 이미 누군가의 고민이었다 3.5 계산기로 사용해보기 3.6 이름을 붙여주자(객체할당) 3.7 컴퓨터에게 “1”은 1이 아니야(문자와 숫자) 3.8 함수와 패키지 3.9 파이프 연산자", " 챕터 3 R 에센셜 3.1 R과 R Studio 설치 먼저 R과 R Studio가 필요하다. R은 프로그래밍 언어 자체고, R Studio는 여러분들의 R 프로그래밍을 조금 더 쉽게 도와줄 친구라고 생각해보자. R Studio나 VS Code와 같이 코딩을 도와주는 친구들을 IDE라고 하는데, 이는 “통합 개발 환경” (Integrated Development Environment)의 약어로 소프트웨어 개발을 위한 툴 또는 프로그램을 이야기한다. 이를 통해 개발자는 소스 코드를 작성, 편집, 디버깅, 테스트 및 배포하는 데 많은 도움을 받을 수 있다. 일단 묻지도 따지지도 말고 일단 Posit 홈페이지에 접속하자. 사용하는 OS에 맞춰 R 버전은 4.0이상, R Studio는 대충 최신 버전으로 설치하면 된다. 3.2 Hello World! R Studio를 실행해보자. 프로그래밍이 처음인 사람이라면 아주 낯선 화면을 마주하게 될 것이다. 묻지도 따지지도 말고 일단 Console이라고 적인 박스에서 꿈뻑거리고 있는 그곳에 아래와 같이 입력하고 경쾌히 엔터키를 눌러보자. print(&quot;Hello World!&quot;) ## [1] &quot;Hello World!&quot; 축하한다! 당신은 세상 모든 프로그래머들의 국룰과 함께 역사적인 첫발을 내딛었다. 부디 새로운 세상(World)에 들어온 이 순간을 잘 기억하시라. R Studio의 인터페이스는 단순하다. Console에 뭔가를 쓰고 입력하기만 하면 된다. 우리는 이것을 ’명령’이라고 부른다. 컴퓨터는 ’명령’한대로 뭔가를 하기 시작할 것이다. 그리고 그 여튼 뭔가 보여준다. 제대로 실행되던지 아니면 오류 메시지를 보여주던지. 만약 미완성된 명령을 입력하면 프롬프트에 +가 표시되는데, 이는 나머지 부분을 더 입력하기를 기다리고 있다는 의미다. 명령을 마저 입력하거나 Esc를 눌러 취소하면 된다. 3.3 예쁜 테마는 일할 맛 나게 해주지 다음으로 해야 할 일은 테마를 바꾸는 것이다. Options &gt; Appearance에서는 R Studio의 테마, 폰트, 폰트사이즈 모두 마음대로 바꿀 수 있다. 이건 마치 공부하기 전 책상정리부터 하는 학생의 마음같은 것이다. 내가 공부할 수 있는 가장 기분좋은 상태를 만들어 보자. 마치 국방부 서버를 침투하는 대단한 해커가 된 것 같은 기분을 내보는 것이 도움이 된다. 3.4 당신의 고민은 이미 누군가의 고민이었다 3.4.1 에러 메시지를 대하는 자세 최고급 개발자조차 에러 메시지는 피할 수 없다. 에러 메시지를 무서워하지 말자. 잘 읽어보면 그 안에 답이 있다. 필자의 경우 에러 메시지를 맞닥뜨리는 이유의 80%는 ‘오탈자’ 때문이다. 그래도 모르겠다면 구글에 에러 메시지를 복붙해 해보자. 당신의 고민은 이미 누군가의 고민이었다. ‘How to ~’와’~ in R’을 적절히 섞어서 검색하다 보면 누군가의 해결방법을 찾을 수 있을 것이다. 물론 고수의 입장에서 본다면 복붙한 코드는 근본적인 해결이 아닌 미봉책에 그치는 경우도 많겠지만 지금 단계에서 그것은 중요하지 않다. 일단 과정 가운데 꾸준히 배우다 보면 결국 근본적인 해결책도 만나게 될 것이다. 영어 문서를 무서워하지 말자. 대부분의 고급 정보는 영어로 제공되곤 한다. 영어를 두려워하는 우리를 위해 구글 번역기, DeepL, 네이버 파파고가 존재하지 않는가? 구글 번역기의 크롬 익스텐션이 보다 빠른 번역을 도와줄 것이다. 외국인이나 한국인이나 맞닥드리는 문제는 근본적으로 크게 다르지 않다. 다만 한국어보다 영어를 쓰는 사람이 많기 때문에 영어로된 질문과 답변에 대한 문서가 훨씬 많을 뿐이다. 3.5 계산기로 사용해보기 R은 계산기로 사용할 수 있다. 1 + 1를 입력하고 엔터키를 눌러보자. 1 + 1 ## [1] 2 R은 사칙연산을 포함한 다양한 연산을 할 수 있다. 원하는 숫자들을 더하고(+) 빼고(-) 곱하고(*) 나눠보자(/). R은 아주 작은수 부터 큰수까지 순식간에 계산해준다. 2 + 2 ## [1] 4 2 - 2 ## [1] 0 2 * 2 ## [1] 4 2 / 2 ## [1] 1 3.6 이름을 붙여주자(객체할당) 내가 그의 이름을 불러주기 전에는 그는 다만 하나의 몸짓에 지나지 않았다. 내가 그의 이름을 불러 주었을 때, 그는 나에게로 와서 꽃이 되었다. – 꽃(김춘수) 앞에서 배운 것처럼 R에게 명령을 내려보았다. 하지만 이것들은 아직 컴퓨터 어디에도 저장되지 않았다. 이미 다 지나간 일이라 다시 사용할 수 없으므로 만약 이것들을 계속해서 사용하고 싶다면 어딘가에 어떠한 형태로든 저장해 놓아야 한다. 이제 객체(object)가 필요할 시간이다. two &lt;- 2 five &lt;- 5 이제 컴퓨터의 메모리 어딘가에 객체가 저장되었다. 객체는 &lt;-를 사용해서 할당할 수 있다(대신 =를 사용할 수도 있지만 사용하지 않기로 하자). 할당된 객체들에 대한 정보는 R Studio의 Environment 탭에서 찾아볼 수 있다. two + 8 ## [1] 10 five * 100 ## [1] 500 two / five ## [1] 0.4 이미 만들어진 객체 이름이라도 덮어 쓸 수 있다. 같은 객체 이름을 두번 사용하지 않도록 조심하자. a &lt;- 100 a ## [1] 100 a &lt;- 9999 a ## [1] 9999 객체명을 할당할 때는 반드시 아래 규칙을 지켜야 한다. 만약 이 규칙을 지키지 않고 아래와 같이 하면 에러가 발생할 것이다. 문자로 시작해야 한다(= 숫자로 시작할 수 없다). 문자, 숫자, _, . 만 포함해야 한다. 123 &lt;- 10 animal!! &lt;- &quot;cow&quot; ## Error: &lt;text&gt;:2:7: unexpected &#39;!&#39; ## 1: 123 &lt;- 10 ## 2: animal! ## ^ 또한 R은 대소문자를 구분한다. Year과 year은 다르다. Year &lt;- 365 year ## Error in eval(expr, envir, enclos): object &#39;year&#39; not found There are only two hard things in Computer Science: cache invalidation and naming things. –Phil Karlton 객체 할당에서 가장 어려운 것은 객체의 이름을 정하는 것이다. 객체명을 정하는 방법과 기준은 개발자 간에 다소 주관적일 수 있으나 일반적인 가이드라인은 다음과 같다. 조금 더 자세한 내용이 알고 싶다면 tidyverse style guide를 참조하자. 명확하고 의미 전달력이 있는 이름 사용: 변수명은 해당 변수의 의도나 기능을 명확하게 전달해야 한다. 다른 사람이 코드를 읽거나 유지보수할 때 이해하기 쉬워야 하기 때문에 의미 있는 단어나 약어를 사용하고, 변수가 나타내는 데이터의 성격이나 용도를 잘 나타내도록 한다. 일반적으로 변수 이름은 명사가, 함수 이름은 동사가 좋다(함수가 무엇인지 아직 몰라도 된다). 카멜 케이스 또는 스네이크 케이스 사용: 변수명을 작성하는 데에는 주로 카멜 케이스(camel case) 또는 스네이크 케이스(snake case)를 사용한다. 카멜 케이스는 첫 번째 단어를 제외한 각 단어의 첫 글자를 대문자로 작성하고, 단어들을 연결하여 작성하는 방식으로 예를 들면 “myVariableName”과 같다. 스네이크 케이스는 모든 단어를 소문자로 작성하고, 단어들을 밑줄로 연결하는 방식으로 예를 들면 “my_variable_name”과 같다. 어떤 케이스를 사용하든지 일관성을 유지하는 것이 중요하다(필자는 스네이크 케이스를 선호한다). 너무 짧은 변수명 피하기: 충분히 명확하지만 지나치게 짧게 작성하는 것은 가독성을 저해할 수 있다. 변수의 용도와 의미를 잘 반영하면서도 충분히 길이가 있는 이름을 선택하는 것이 좋다. R Studio를 포함한 대부분의 IDE들에서는 할당된 객체에 대한 자동완성 기능을 제공한다. 일관성 유지: 프로젝트 전체에서 일관된 변수명 규칙을 사용하는 것이 좋다. 같은 종류의 변수는 같은 규칙에 따라 명명되어야 하며, 다른 개발자들과의 협업 시에도 일관성을 유지할 수 있다. 발음하기 쉬운 변수명 쓰기: 혼자 일하지 않는 경우도 많다. Worcestershire같은 변수명을 쓰다간 동료에게 맞는 불상사가 생길 수도 있다. 그리고 생각보다 한글 변수명도 잘 읽는다. 물론 한영전환이 불편할 수도 있고 만약 외국인들과 일한다면 소통의 어려움이 있겠지만, 개인적인 프로젝트라면 보다 풍부한 변수명을 쓸 수도 있다. 무엇보다 특정 도메인에 특화된 프로그래밍을 할 때, 한글 변수명을 사용하면 도메인 용어와의 일치도를 높일 수 있다. 한국어 자연어 처리와 같이 한글을 다루는 분야에서 변수명과 관련 용어들 간의 일관성을 유지하기 쉽다. 아름다운우리한글 &lt;- 99.9 아름다운우리한글 ## [1] 99.9 3.7 컴퓨터에게 “1”은 1이 아니야(문자와 숫자) R은 사람이 콕 찝어 알려주기 전까지는 숫자(number)와 문자(character)를 온전히 구분하지 못한다. 아래 두 사칙연산 결과를 비교해 보자. 5 + 5 ## [1] 10 &quot;5&quot; + &quot;5&quot; ## Error in &quot;5&quot; + &quot;5&quot;: non-numeric argument to binary operator 5 + 5는 정확하게 계산값을 뱉어내지만 \"5\" + \"5\"는 non-numeric argument라 계산할 수 없다는 에러 메시지를 뱉는다. 이는 R에서 5는 \"5\"와 다르기 때문이다. 숫자는 더하거나 뺄 수 있지만, 문자는 불가능하다(우리가 철수에서 영희를 빼지 못하는 것처럼). R은 쌍따옴표(\")로 감싸진 것들은 문자라고 인식하기 때문에 5 + \"5\"는 계산이 불가능하다. 반드시 숫자는 숫자를 다루는 방식으로, 문자는 문자를 다루는 방식으로 다뤄져야 한다. 자료의 속성을 가장 쉽게 확인해보는 방법은 str() 함수를 사용하는 것이다 str(5) ## num 5 str(&quot;5&quot;) ## chr &quot;5&quot; num은 numeric (숫자)을 의미하고 chr은 character (문자)를 의미한다. 명심하자. 우리는 오 더하기 오와 5 + 5를 보며 같은 결과를 도출하지만 R은 개떡같이 말해도 찰떡같이 알아먹을 줄 모른다. chatGPT는 알아 먹던데.. 3.8 함수와 패키지 3.8.1 함수란? R에서 함수란 입력값을 받아서 출력값을 내놓는 작은 도구이다. 함수는 function() 함수를 사용하여 정의할 수 있다. 아래는 add()라는 함수를 정의하는 예제이다. add() 함수는 두 개의 숫자를 입력받아 더한 값을 출력한다. add &lt;- function(x, y) { x + y } add(x = 5, y = 5) ## [1] 10 함수는 이런 단순한 계산에서 부터 시작해서 시각화, 딥러닝까지 다양한 목적으로 사용될 수 있다. R은 기본적으로 내장하고 있는 함수들이 있으며, 손쉽게 꺼내 쓸수 있다. mean() 함수는 입력값의 평균을 계산해주는 함수이다. 아래는 mean() 함수를 사용하는 예제이다. mean(x = 1:10) ## [1] 5.5 1:10은 1부터 10까지의 숫자를 의미한다. mean() 함수는 이 숫자들의 평균을 계산하여 출력한다. mean() 함수는 x라는 입력값을 받는다. x는 1:10이라는 숫자 벡터이다. mean() 함수는 x에 해당하는 숫자들의 평균을 계산하여 출력한다. mean() 함수는 x라는 입력값을 받는다. x는 1:10이라는 숫자 벡터이다. mean() 함수는 x에 해당하는 숫자들의 평균을 계산하여 출력한다. 3.8.2 함수들의 꾸러미, 패키지 함수가 단일 작업을 수행하는 작은 도구 하나라면, 패키지는 그 도구들이 모여 있는 큰 도구상자다. 각 패키지는 특정 기능을 수행하기 위해 필요한 함수와 데이터를 제공하며, 사용자는 패키지를 설치하고 로드하여 해당 기능을 사용할 수 있다. 패키지는 R의 기본 기능을 확장하고, 다양한 도메인에 특화된 기능을 제공하여 데이터 분석, 시각화, 모델링 등 다양한 작업을 수행할 수 있도록 도와준다. 3.8.3 주요 패키지 설치 3.8.3.1 CRAN을 통한 설치 R은 오픈소스로 많은 사람들이 만들고 공개한 패키지를 손쉽게 사용할 수 있다. 패키지를 설치하는 가장 쉬운 방법은 install.package() 함수를 사용하는 것인데, 이는 CRAN(The Comprehensive R Archive Network)이라는 저장소에 올라가 있는 R 패키지를 다운로드 받는다. 현재 CRAN에서 다운로드 가능한 패키지는 아래와 같다. 아래는 tidyverse라는 패키지를 설치하는 예제이다. install.packages(&quot;tidyverse&quot;) 3.8.3.2 Github을 통한 설치 Github은 소프트웨어 개발자들이 소스코드를 공유하는 플랫폼이다. Github에는 CRAN에 올라가지 않은 패키지들도 많이 올라와 있다. 이 패키지들은remotes패키지의 install_github() 함수를 사용하여 설치할 수 있다. 다만 Github에 업로드 되어 있는 패키지들은 CRAN에 비해 peer-review가 되어 있지 않아 테스트가 덜 되어 있을 수 있으므로 주의가 필요하다. 아래는 datatoys라는 패키지를 설치하는 예제이다. install.packages(&quot;remotes&quot;) # if required remotes::install_github(&quot;statgarten/datatoys&quot;) 3.8.3.3 패키지 불러오기 불러온 패키지는 R 세션이 재시작 될 때마다(R을 실행하고 종료할 때 마다) 초기화 된다. 한마디로, 새로운 세션이 시작될 때 마다 library() 함수를 다시 실행해 줘야 한다. library(dplyr) 만약 library() 함수를 사용하지 않고 특정 패키지에 있는 데이터셋이나 함수를 한번만 불러오고 싶다면 ::를 사용할 수 있다. petNames라는 데이터셋은 패키지 로딩 없이는 꺼낼 수 없지만(에러 메시지를 출력한다), head(petNames) ## # A tibble: 6 × 2 ## 동물이름 건수 ## &lt;chr&gt; &lt;dbl&gt; ## 1 보리 38 ## 2 구름 25 ## 3 토리 25 ## 4 콩이 21 ## 5 코코 19 ## 6 라떼 17 ::를 아래와 같이 사용하면 패키지 로딩 없이 필요한 데이터셋이나 함수만 쏙 빼올 수도 있다. head(datatoys::petNames) ## # A tibble: 6 × 2 ## 동물이름 건수 ## &lt;chr&gt; &lt;dbl&gt; ## 1 보리 38 ## 2 구름 25 ## 3 토리 25 ## 4 콩이 21 ## 5 코코 19 ## 6 라떼 17 3.8.3.4 의존성 문제 R을 사용하다보면 여러가지 패키지들을 함께 사용할 경우가 대부분이고, 사용하는 패키지가 많아질 수록 한 패키지가 다른 패키지의 함수를 빌려다 쓰는 의존성(Dependency)이 증가하게 된다. 그러다보면 의존된 패키지가 누락되거나 업데이트 되었을 때 해당 함수가 정상적으로 동작하지 않을 수도 있다. 예를 들어, “ggplot2” 패키지는 “dplyr” 패키지의 함수를 사용하여 데이터를 전처리하기도 한다. 따라서 “ggplot2” 패키지를 사용하려면 “dplyr” 패키지가 먼저 설치되어 있어야 한다. 따라서 패키지를 업데이트할 때는 의존하는 다른 패키지와의 호환성을 고려해야 한다. 이러한 문제를 해결하기 위해 R에서는 패키지 의존성을 자동으로 관리해주는 도구인 패키지 관리자를 제공한다. 패키지 관리자는 의존하는 패키지를 자동으로 설치하거나 업데이트하고, 패키지 간의 충돌을 최소화하여 코드의 정상 작동을 보장한다. 문제가 생길 수 있다고 인식하고 있되, 너무 걱정하지는 말자. 3.9 파이프 연산자 3.9.1 파이프 연산자란? 파이프 연산자는 함수를 연결하여 사용할 때 유용하게 사용할 수 있는 연산자다. 파이프 연산자는 %&gt;%로 표현하며, 왼쪽에 있는 값을 오른쪽에 있는 함수의 첫 번째 인자로 전달한다. 파이프 연산자를 사용하면 함수를 연결하여 사용할 때 코드의 가독성을 높일 수 있다. 앞으로의 모든 분석에서 파이프 연산자를 함께 사용할 것이다. 따라서 본 개념을 정확하게 익히고 가도록 하자. library(dplyr) library(datatoys) head(petNames) ## # A tibble: 6 × 2 ## 동물이름 건수 ## &lt;chr&gt; &lt;dbl&gt; ## 1 보리 38 ## 2 구름 25 ## 3 토리 25 ## 4 콩이 21 ## 5 코코 19 ## 6 라떼 17 petNames %&gt;% head() ## # A tibble: 6 × 2 ## 동물이름 건수 ## &lt;chr&gt; &lt;dbl&gt; ## 1 보리 38 ## 2 구름 25 ## 3 토리 25 ## 4 콩이 21 ## 5 코코 19 ## 6 라떼 17 위 head(petNames)와 petNames %&gt;% head()는 동일한 결과를 출력한다. head함수의 첫 번째 인자로 petNames를 전달하는 대신, petNames를 %&gt;%의 왼쪽에 두어 head 함수의 첫 번째 인자로 전달한 것이다. 이처럼 파이프 연산자는 함수를 연결하여 사용할 때 유용하게 사용할 수 있다. "],["데이터-주무르기.html", "챕터 4 데이터 주무르기 4.1 datatoys 패키지 소개 4.2 데이터프레임 이해 4.3 음주운전 데이터 주무르기 4.4 데이터라는 것이 폭발한다. 합쳤을 때.", " 챕터 4 데이터 주무르기 씹고 뜯고 맛보고 즐기고 – 이가탄 4.1 datatoys 패키지 소개 Play gives children a chance to practice what they are learning – Fred Rogers 데이터를 분석하는데 있어서 가장 큰 장벽은 데이터를 읽어오고, 분석에 알맞는 형태로 만드는 작업이다. datatoys 패키지는 공공데이터포털에서 제공하는 각종 데이터를 R에서 곧바로 분석할 수 있는 상태로 제공한다(python 버전도 있지만 R이 조금 먼저 개발된다). 패키지의 이름처럼 마치 어린 아이가 데이터를 재밌는 장난감처럼 갖고 놀 수 있도록 함이 목적이다. 본 챕터에서는 datatoys 패키지를 활용하여 데이터를 주무르는 방법을 배워보도록 하자. library(datatoys) datatoys패키지에서 제공하는 데이터셋에 대한 자세한 정보는 문서를 통해 확인할 수 있다. 또는 ?를 활용해 다음 ?accident과 같이 확인할 수 있다. 4.2 데이터프레임 이해 이미지, 영상, 문서 같이 여러가지 형태의 데이터가 있지만, 우리는 직사각형처럼 생긴 데이터(데이터프레임)에 초점을 맞출 것이다. 데이터프레임은 행과 열로 이루어진 표 형태의 데이터이다. 행은 관측치를, 열은 변수를 의미한다. library(datatoys) library(dplyr) str(restaurant) ## tibble [137 × 9] (S3: tbl_df/tbl/data.frame) ## $ 시군명 : chr [1:137] &quot;가평군&quot; &quot;고양시&quot; &quot;고양시&quot; &quot;고양시&quot; ... ## $ 음식점명 : chr [1:137] &quot;가평축협 한우명가&quot; &quot;청정바지락칼국수&quot; &quot;양촌리아구&quot; &quot;정통중화요리 남궁&quot; ... ## $ 맛집전화번호 : chr [1:137] &quot;031-581-1592&quot; &quot;031-912-7676&quot; &quot;031-911-0430&quot; &quot;031-911-3702&quot; ... ## $ 대표음식명 : chr [1:137] &quot;푸른연잎한우명품꽃등심&quot; &quot;천년초들깨수제비&quot; &quot;아구탕&quot; &quot;해물고추짬뽕, 양장피잡채&quot; ... ## $ 소재지우편번호 : chr [1:137] &quot;12422&quot; &quot;10359&quot; &quot;10218&quot; &quot;10367&quot; ... ## $ 소재지도로명주소: chr [1:137] &quot;경기도 가평군 가평읍 달전로 19&quot; &quot;경기도 고양시 일산동구 일산로463번길 7&quot; &quot;경기도 고양시 일산서구 대화2로 152&quot; &quot;경기도 고양시 일산서구 일산로 682&quot; ... ## $ 소재지지번주소 : chr [1:137] &quot;경기도 가평군 가평읍 달전리 382-1번지&quot; &quot;경기도 고양시 일산동구 정발산동 1148번지&quot; &quot;경기도 고양시 일산서구 대화동 762-3번지&quot; &quot;경기도 고양시 일산서구 대화동 2101번지&quot; ... ## $ WGS84위도 : chr [1:137] &quot;37.8158443&quot; &quot;37.6737073&quot; &quot;37.6719314&quot; &quot;37.6820421&quot; ... ## $ WGS84경도 : chr [1:137] &quot;127.5161283&quot; &quot;126.7753751&quot; &quot;126.7362187&quot; &quot;126.7535498&quot; ... restaurant 데이터는 137개의 관측치와 9개의 변수로 이루어져 있다. 각 행은 경기도 한 음식점을 의미하고, 열은 음식점의 정보를 의미한다. 시군명, 음식점명, 맛집 전화번호, 대표 음식명, 소재지 우편번호 등의 정보를 제공한다. 4.3 음주운전 데이터 주무르기 datatoys 패키지에는 drunkdrive라는 데이터셋이 있다. 이 데이터는 경찰청에서 음주운전 적발기록을 통한 음주예방을 위해 경찰처에서 공개한 자료로 성별, 적발횟수, 나이, 알콜농도, 측정일시, 관할경찰서 등의 정보를 제공한다. head() 함수를 통해 어떤 모양으로 생긴 데이터인지부터 확인해보자. head(drunkdrive) ## # A tibble: 6 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 29 0.153 2022-07-01 00:00:00 아산경찰서 정상 측정 ## 2 남자 1 28 0.046 2022-07-01 00:02:00 전주덕진경찰서 정상 측정 ## 3 남자 1 61 0.047 2022-07-01 00:02:00 서울관악경찰서 정상 측정 ## 4 여자 1 40 0.185 2022-07-01 00:04:00 부산연제경찰서 정상 측정 ## 5 남자 1 66 0.139 2022-07-01 00:05:00 서울마포경찰서 정상 측정 ## 6 남자 1 31 0.214 2022-07-01 00:05:00 대전중부경찰서 정상 측정 데이터를 주무르기 위한 많은 패키지가 있지만, 가장 많은 사람들이 사용하는 dplyr라는 최적의 패키지가 있다. 이번 챕터에서는 dplyr에서 가장 많이 사용되는 몇가지 함수를 배워보도록 하자. library(dplyr) 4.3.1 select() drunkdrive는 총 8가지 변수를 갖고 있다. 너무 많은 데이터들에 압도당하지 않으려면 필요한 변수만 선택(select) 할 필요가 있다. select 함수는 데이터셋에서 필요한 변수(열)만을 선택할 때 사용한다. 성별, 적발횟수, 나이, 알콜농도 열만 선택해보자. drunkdrive %&gt;% select(성별, 적발횟수, 나이, 알콜농도) ## # A tibble: 12,021 × 4 ## 성별 적발횟수 나이 알콜농도 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 남자 1 29 0.153 ## 2 남자 1 28 0.046 ## 3 남자 1 61 0.047 ## 4 여자 1 40 0.185 ## 5 남자 1 66 0.139 ## 6 남자 1 31 0.214 ## 7 남자 1 26 0.136 ## 8 남자 1 44 0.084 ## 9 여자 1 59 0.184 ## 10 남자 1 23 0.164 ## # … with 12,011 more rows 데이터가 훨씬 간결해졌다. :를 사용하면 범위를 지정할 수도 있다. 동일한 결과를 보여준다. drunkdrive %&gt;% select(성별:알콜농도) ## # A tibble: 12,021 × 4 ## 성별 적발횟수 나이 알콜농도 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 남자 1 29 0.153 ## 2 남자 1 28 0.046 ## 3 남자 1 61 0.047 ## 4 여자 1 40 0.185 ## 5 남자 1 66 0.139 ## 6 남자 1 31 0.214 ## 7 남자 1 26 0.136 ## 8 남자 1 44 0.084 ## 9 여자 1 59 0.184 ## 10 남자 1 23 0.164 ## # … with 12,011 more rows 때로는 필요한 변수를 제외하고 싶을 때도 있다. 이때는 -를 사용하면 된다. 성별, 적발횟수, 나이, 알콜농도 열을 제외하고 보고 싶다면 다음과 같이 사용하면 된다. drunkdrive %&gt;% select(-성별, -적발횟수, -나이, -알콜농도) ## # A tibble: 12,021 × 4 ## 측정일시 관할경찰서 나이불명 측정 ## &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2022-07-01 00:00:00 아산경찰서 정상 측정 ## 2 2022-07-01 00:02:00 전주덕진경찰서 정상 측정 ## 3 2022-07-01 00:02:00 서울관악경찰서 정상 측정 ## 4 2022-07-01 00:04:00 부산연제경찰서 정상 측정 ## 5 2022-07-01 00:05:00 서울마포경찰서 정상 측정 ## 6 2022-07-01 00:05:00 대전중부경찰서 정상 측정 ## 7 2022-07-01 00:10:00 안산상록경찰서 정상 측정 ## 8 2022-07-01 00:13:00 부산사상경찰서 정상 측정 ## 9 2022-07-01 00:13:00 군산경찰서 정상 측정 ## 10 2022-07-01 00:13:00 대구북부경찰서 정상 측정 ## # … with 12,011 more rows 때론 데이터 열의 순서를 바꾸고 싶을 때가 있다. everything() 함수를 함께 활용하면 데이터셋의 남은 모든 열을 선택할 수 있다. drunkdrive %&gt;% select(알콜농도, 적발횟수, 나이, everything()) ## # A tibble: 12,021 × 8 ## 알콜농도 적발횟수 나이 성별 측정일시 관할경찰서 나이불명 측정 ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 0.153 1 29 남자 2022-07-01 00:00:00 아산경찰서 정상 측정 ## 2 0.046 1 28 남자 2022-07-01 00:02:00 전주덕진경찰서 정상 측정 ## 3 0.047 1 61 남자 2022-07-01 00:02:00 서울관악경찰서 정상 측정 ## 4 0.185 1 40 여자 2022-07-01 00:04:00 부산연제경찰서 정상 측정 ## 5 0.139 1 66 남자 2022-07-01 00:05:00 서울마포경찰서 정상 측정 ## 6 0.214 1 31 남자 2022-07-01 00:05:00 대전중부경찰서 정상 측정 ## 7 0.136 1 26 남자 2022-07-01 00:10:00 안산상록경찰서 정상 측정 ## 8 0.084 1 44 남자 2022-07-01 00:13:00 부산사상경찰서 정상 측정 ## 9 0.184 1 59 여자 2022-07-01 00:13:00 군산경찰서 정상 측정 ## 10 0.164 1 23 남자 2022-07-01 00:13:00 대구북부경찰서 정상 측정 ## # … with 12,011 more rows datatoys 패키지에는 장소별 원인별 화재통계를 제공하는 fire이라는 데이터셋이 있다. 데이터는 아래와 같은 열로 구성되어 있다. str(fire) ## tibble [44,435 × 18] (S3: tbl_df/tbl/data.frame) ## $ 연번 : int [1:44435] 1 2 3 4 5 6 7 8 9 10 ... ## $ 사망 : int [1:44435] 0 0 0 0 0 0 0 0 0 0 ... ## $ 부상 : int [1:44435] 0 0 0 0 0 0 0 0 0 0 ... ## $ 인명피해.명.소계: int [1:44435] 0 0 0 0 0 0 0 0 0 0 ... ## $ 재산피해소계 : int [1:44435] 2920 0 137 326 0 19800 33 30800 0 575 ... ## $ 시도 : chr [1:44435] &quot;경상남도&quot; &quot;서울특별시&quot; &quot;서울특별시&quot; &quot;서울특별시&quot; ... ## $ 시군구 : chr [1:44435] &quot;합천군&quot; &quot;영등포구&quot; &quot;강남구&quot; &quot;도봉구&quot; ... ## $ 읍면동 : chr [1:44435] &quot;청덕면&quot; &quot;여의도동&quot; &quot;논현동&quot; &quot;쌍문동&quot; ... ## $ 발화열원 : chr [1:44435] &quot;작동기기&quot; &quot;담뱃불, 라이터불&quot; &quot;담뱃불, 라이터불&quot; &quot;담뱃불, 라이터불&quot; ... ## $ 발화열원소분류 : chr [1:44435] &quot;전기적 아크(단락)&quot; &quot;담뱃불&quot; &quot;담뱃불&quot; &quot;담뱃불&quot; ... ## $ 발화요인대분류 : chr [1:44435] &quot;전기적 요인&quot; &quot;부주의&quot; &quot;부주의&quot; &quot;부주의&quot; ... ## $ 발화요인소분류 : chr [1:44435] &quot;접촉불량에 의한 단락&quot; &quot;담배꽁초&quot; &quot;담배꽁초&quot; &quot;담배꽁초&quot; ... ## $ 최초착화물대분류: chr [1:44435] &quot;전기,전자&quot; &quot;기타&quot; &quot;침구,직물류&quot; &quot;종이,목재,건초등&quot; ... ## $ 최초착화물소분류: chr [1:44435] &quot;전선피복&quot; &quot;기타&quot; &quot;기타(침구,직물류)&quot; &quot;기타(종이,목재,건초등)&quot; ... ## $ 장소대분류 : chr [1:44435] &quot;주거&quot; &quot;임야&quot; &quot;자동차,철도차량&quot; &quot;판매,업무시설&quot; ... ## $ 장소중분류 : chr [1:44435] &quot;단독주택&quot; &quot;들불&quot; &quot;자동차&quot; &quot;일반업무&quot; ... ## $ 장소소분류 : chr [1:44435] &quot;단독주택&quot; &quot;기타 들불&quot; &quot;오토바이&quot; &quot;일반빌딩&quot; ... ## $ 지번동 : chr [1:44435] &quot;청덕면&quot; &quot;여의도동&quot; &quot;논현1동&quot; &quot;쌍문2동&quot; ... starts_with()와 ends_with() 함수를 함께 활용하면, 특정 문자열로 시작하는 열이나 특정 문자열로 끝나는 열을 선택할 수 있다. 장소로 시작하는 열을 선택해보자. fire %&gt;% select(starts_with(&quot;장소&quot;)) ## # A tibble: 44,435 × 3 ## 장소대분류 장소중분류 장소소분류 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 주거 단독주택 단독주택 ## 2 임야 들불 기타 들불 ## 3 자동차,철도차량 자동차 오토바이 ## 4 판매,업무시설 일반업무 일반빌딩 ## 5 주거 공동주택 다세대주택 ## 6 자동차,철도차량 자동차 승용자동차 ## 7 생활서비스 오락시설 PC방(인터넷게임제공업) ## 8 자동차,철도차량 자동차 승용자동차 ## 9 기타 야외 기타야외 ## 10 생활서비스 일상서비스 기타 일상서비스 ## # … with 44,425 more rows 분류로 끝나는 열을 선택해보자. fire %&gt;% select(ends_with(&quot;분류&quot;)) ## # A tibble: 44,435 × 8 ## 발화열원소분류 발화요인대분류 발화요인소분류 최초착화물대분류 최초착화물소분류 장소대분류 장소중분류 장소소분류 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 전기적 아크(단락) 전기적 요인 접촉불량에 의한 단락 전기,전자 전선피복 주거 단독주택 단독주택 ## 2 담뱃불 부주의 담배꽁초 기타 기타 임야 들불 기타 들불 ## 3 담뱃불 부주의 담배꽁초 침구,직물류 기타(침구,직물류) 자동차,철도차량 자동차 오토바이 ## 4 담뱃불 부주의 담배꽁초 종이,목재,건초등 기타(종이,목재,건초등) 판매,업무시설 일반업무 일반빌딩 ## 5 기기 전도,복사열 부주의 음식물 조리중 식품 음식물 주거 공동주택 다세대주택 ## 6 기기 전도,복사열 기계적 요인 과열, 과부하 자동차,철도차량,선박,항공기 벨트 자동차,철도차량 자동차 승용자동차 ## 7 담뱃불 부주의 담배꽁초 종이,목재,건초등 종이 생활서비스 오락시설 PC방(인터넷게임제공업) ## 8 미상 미상 미상 미상 미상 자동차,철도차량 자동차 승용자동차 ## 9 모닥불, 연탄, 숯 부주의 불씨,불꽃,화원방치 종이,목재,건초등 풀, 나뭇잎 기타 야외 기타야외 ## 10 전기적 아크(단락) 전기적 요인 절연열화에 의한 단락 전기,전자 전선피복 생활서비스 일상서비스 기타 일상서비스 ## # … with 44,425 more rows contains() 함수를 사용하면 특정 문자열을 포함하는 열을 선택할 수 있다. 요인이라는 문자열을 포함하는 열을 선택해보자. fire %&gt;% select(contains(&quot;요인&quot;)) ## # A tibble: 44,435 × 2 ## 발화요인대분류 발화요인소분류 ## &lt;chr&gt; &lt;chr&gt; ## 1 전기적 요인 접촉불량에 의한 단락 ## 2 부주의 담배꽁초 ## 3 부주의 담배꽁초 ## 4 부주의 담배꽁초 ## 5 부주의 음식물 조리중 ## 6 기계적 요인 과열, 과부하 ## 7 부주의 담배꽁초 ## 8 미상 미상 ## 9 부주의 불씨,불꽃,화원방치 ## 10 전기적 요인 절연열화에 의한 단락 ## # … with 44,425 more rows select()함수는 ’열’을 선택할 때 사용한다. 만약 ’행’을 선택하고 싶다면 slice() 함수를 사용할 수 있다. slice() 함수는 데이터셋에서 특정 행을 선택할 때 사용한다. 1, 3, 5, 7, 9번 행을 선택해보자. drunkdrive %&gt;% slice(1, 3, 5, 7, 9) ## # A tibble: 5 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 29 0.153 2022-07-01 00:00:00 아산경찰서 정상 측정 ## 2 남자 1 61 0.047 2022-07-01 00:02:00 서울관악경찰서 정상 측정 ## 3 남자 1 66 0.139 2022-07-01 00:05:00 서울마포경찰서 정상 측정 ## 4 남자 1 26 0.136 2022-07-01 00:10:00 안산상록경찰서 정상 측정 ## 5 여자 1 59 0.184 2022-07-01 00:13:00 군산경찰서 정상 측정 연결된 행을 선택하기 위해서는 :를 활용할 수 있다. drunkdrive %&gt;% slice(1:5) ## # A tibble: 5 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 29 0.153 2022-07-01 00:00:00 아산경찰서 정상 측정 ## 2 남자 1 28 0.046 2022-07-01 00:02:00 전주덕진경찰서 정상 측정 ## 3 남자 1 61 0.047 2022-07-01 00:02:00 서울관악경찰서 정상 측정 ## 4 여자 1 40 0.185 2022-07-01 00:04:00 부산연제경찰서 정상 측정 ## 5 남자 1 66 0.139 2022-07-01 00:05:00 서울마포경찰서 정상 측정 4.3.2 arrange() 뭐든 비교하고 줄세우는건 재밌다. 우리가 그 대상이 아니라면 말이다. arrange() 함수를 사용하면 데이터를 쉽게 정렬할 수 있다. arrange() 함수는 데이터셋에서 특정 열을 기준으로 정렬할 때 사용한다. drunkdrive데이터셋은 음주운전 적발자의 정보를 담고 있다. 나이를 기준으로 정렬하면 어떤 결과가 나올까? drunkdrive %&gt;% arrange(나이) ## # A tibble: 12,021 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 -77 0.168 2022-07-16 05:31:00 동두천경찰서 정상 측정 ## 2 남자 1 14 0.112 2022-07-17 03:38:00 원주경찰서 정상 측정 ## 3 남자 1 15 0.114 2022-07-02 03:51:00 공주경찰서 정상 측정 ## 4 남자 1 15 0.058 2022-07-10 03:28:00 나주경찰서 정상 측정 ## 5 여자 1 15 0.066 2022-07-25 07:12:00 안산상록경찰서 정상 측정 ## 6 남자 1 16 0.083 2022-07-03 02:19:00 서울강북경찰서 정상 측정 ## 7 남자 1 16 0.124 2022-07-03 02:40:00 천안동남경찰서 정상 측정 ## 8 남자 1 16 0.13 2022-07-04 01:21:00 서울중랑경찰서 정상 측정 ## 9 남자 1 16 0.091 2022-07-05 02:58:00 창원중부경찰서 정상 측정 ## 10 남자 1 16 0.075 2022-07-05 19:35:00 전주덕진경찰서 정상 측정 ## # … with 12,011 more rows Outlier다! Outlier를 발견했다. -77살은 존재할 수 없는 나이다. -77살을 제외하고 보면 2022년 7월 원주에서 적발된 14살이 가장 어린 나이다. arrange()함수는 기본적으로 작은수부터 정렬한다. desc()를 함께 사용하면 큰 수부터 정렬할 수 있다. 알콜농도가 높은 순서대로 정렬해보자. drunkdrive %&gt;% arrange(desc(알콜농도)) ## # A tibble: 12,021 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 67 0.93 2022-07-18 22:27:00 서울서초경찰서 정상 측정 ## 2 남자 1 45 0.77 2022-07-06 20:56:00 수원서부경찰서 정상 측정 ## 3 남자 1 50 0.66 2022-07-03 18:46:00 안산상록경찰서 정상 측정 ## 4 남자 1 57 0.423 2022-07-20 14:30:00 의령경찰서 정상 측정 ## 5 남자 1 53 0.404 2022-07-04 16:50:00 일산동부경찰서 정상 측정 ## 6 남자 1 38 0.403 2022-07-02 14:14:00 구미경찰서 정상 측정 ## 7 여자 1 30 0.396 2022-07-20 02:24:00 양산경찰서 정상 측정 ## 8 남자 1 52 0.385 2022-07-23 23:17:00 오산경찰서 정상 측정 ## 9 남자 1 43 0.379 2022-07-30 11:24:00 서울송파경찰서 정상 측정 ## 10 남자 1 33 0.378 2022-07-31 23:37:00 인천논현경찰서 정상 측정 ## # … with 12,011 more rows 2022년 7월 서울시 서초구에서 적발된 67세 남성의 알콜농도는 0.93으로 가장 높았다. 나이가 어린 순으로 정렬하면서 만약 나이가 같은 경우 알콜농도가 높은 순서대로 정렬하고 싶으면 다음과 같이 활용할 수 있다. drunkdrive %&gt;% arrange(나이, desc(알콜농도)) ## # A tibble: 12,021 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 -77 0.168 2022-07-16 05:31:00 동두천경찰서 정상 측정 ## 2 남자 1 14 0.112 2022-07-17 03:38:00 원주경찰서 정상 측정 ## 3 남자 1 15 0.114 2022-07-02 03:51:00 공주경찰서 정상 측정 ## 4 여자 1 15 0.066 2022-07-25 07:12:00 안산상록경찰서 정상 측정 ## 5 남자 1 15 0.058 2022-07-10 03:28:00 나주경찰서 정상 측정 ## 6 남자 1 16 0.14 2022-07-17 03:26:00 용인서부경찰서 정상 측정 ## 7 남자 1 16 0.137 2022-07-17 02:32:00 홍성경찰서 정상 측정 ## 8 남자 1 16 0.13 2022-07-04 01:21:00 서울중랑경찰서 정상 측정 ## 9 남자 1 16 0.124 2022-07-03 02:40:00 천안동남경찰서 정상 측정 ## 10 남자 1 16 0.103 2022-07-30 05:24:00 고양경찰서 정상 측정 ## # … with 12,011 more rows 4.3.3 filter() 그렇다면 음주측정을 거부한 사람들이 있을까? 조건에 맞는 행만 뽑아내고 싶을 때는 filter() 함수를 사용해보자. filter() 함수는 조건이 TRUE인 데이터만을 선택할 때 사용한다. 측정이라는 열에서 거부인 데이터만 뽑아보자. drunkdrive %&gt;% filter(측정 == &quot;거부&quot;) ## # A tibble: 457 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 49 NA 2022-07-01 00:23:00 영암경찰서 정상 거부 ## 2 남자 1 33 NA 2022-07-01 01:05:00 안산상록경찰서 정상 거부 ## 3 남자 1 37 NA 2022-07-01 01:10:00 서울서대문경찰서 정상 거부 ## 4 여자 1 25 NA 2022-07-01 03:04:00 광주서부경찰서 정상 거부 ## 5 남자 1 42 NA 2022-07-01 04:16:00 진해경찰서 정상 거부 ## 6 남자 1 43 NA 2022-07-01 06:05:00 청주청원경찰서 정상 거부 ## 7 남자 1 64 NA 2022-07-01 16:47:00 성주경찰서 정상 거부 ## 8 남자 1 66 NA 2022-07-01 20:14:00 괴산경찰서 정상 거부 ## 9 남자 1 32 NA 2022-07-01 21:07:00 안양동안경찰서 정상 거부 ## 10 남자 1 57 NA 2022-07-01 21:57:00 서울강서경찰서 정상 거부 ## # … with 447 more rows 남자(또는 여자)만 뽑아낼 수도, drunkdrive %&gt;% filter(성별 == &quot;남자&quot;) ## # A tibble: 10,629 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 29 0.153 2022-07-01 00:00:00 아산경찰서 정상 측정 ## 2 남자 1 28 0.046 2022-07-01 00:02:00 전주덕진경찰서 정상 측정 ## 3 남자 1 61 0.047 2022-07-01 00:02:00 서울관악경찰서 정상 측정 ## 4 남자 1 66 0.139 2022-07-01 00:05:00 서울마포경찰서 정상 측정 ## 5 남자 1 31 0.214 2022-07-01 00:05:00 대전중부경찰서 정상 측정 ## 6 남자 1 26 0.136 2022-07-01 00:10:00 안산상록경찰서 정상 측정 ## 7 남자 1 44 0.084 2022-07-01 00:13:00 부산사상경찰서 정상 측정 ## 8 남자 1 23 0.164 2022-07-01 00:13:00 대구북부경찰서 정상 측정 ## 9 남자 1 33 0.17 2022-07-01 00:15:00 의왕경찰서 정상 측정 ## 10 남자 1 37 0.144 2022-07-01 00:16:00 광주북부경찰서 정상 측정 ## # … with 10,619 more rows 미성년자만 뽑아낼 수도 있다. 어른들이 보다 관심을 가지고 돌봐줘야 할 아이들이 무려 148명이나 존재한다. drunkdrive %&gt;% filter(나이 &lt; 20) ## # A tibble: 148 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 18 0.158 2022-07-02 02:56:00 천안서북경찰서 정상 측정 ## 2 남자 1 15 0.114 2022-07-02 03:51:00 공주경찰서 정상 측정 ## 3 남자 1 18 0.237 2022-07-02 23:13:00 용인서부경찰서 정상 측정 ## 4 남자 1 19 0.03 2022-07-03 02:18:00 화순경찰서 정상 측정 ## 5 남자 1 16 0.083 2022-07-03 02:19:00 서울강북경찰서 정상 측정 ## 6 남자 1 16 0.124 2022-07-03 02:40:00 천안동남경찰서 정상 측정 ## 7 남자 1 19 0.149 2022-07-03 05:18:00 밀양경찰서 정상 측정 ## 8 남자 1 19 0.049 2022-07-03 08:20:00 광주서부경찰서 정상 측정 ## 9 남자 1 17 0.045 2022-07-03 23:03:00 김해서부경찰서 정상 측정 ## 10 남자 1 19 0.07 2022-07-04 01:01:00 부천원미경찰서 정상 측정 ## # … with 138 more rows is.na() 함수를 사용해 결측치(NA)를 뽑아낼 수 있다. NA는 Not Available의 약자로 결측치를 의미한다. drunkdrive %&gt;% filter(is.na(측정일시)) ## # A tibble: 0 × 8 ## # … with 8 variables: 성별 &lt;fct&gt;, 적발횟수 &lt;int&gt;, 나이 &lt;dbl&gt;, 알콜농도 &lt;dbl&gt;, 측정일시 &lt;dttm&gt;, 관할경찰서 &lt;chr&gt;, 나이불명 &lt;chr&gt;, 측정 &lt;chr&gt; 하지만 대부분의 상황에서는 결측치를 찾아내기 보다. 결측치를 제거하는데 더 자주 사용된다. 결측치를 제거하고 싶다면 !is.na()를 사용하면 된다. drunkdrive %&gt;% filter(!is.na(측정일시)) ## # A tibble: 12,021 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 29 0.153 2022-07-01 00:00:00 아산경찰서 정상 측정 ## 2 남자 1 28 0.046 2022-07-01 00:02:00 전주덕진경찰서 정상 측정 ## 3 남자 1 61 0.047 2022-07-01 00:02:00 서울관악경찰서 정상 측정 ## 4 여자 1 40 0.185 2022-07-01 00:04:00 부산연제경찰서 정상 측정 ## 5 남자 1 66 0.139 2022-07-01 00:05:00 서울마포경찰서 정상 측정 ## 6 남자 1 31 0.214 2022-07-01 00:05:00 대전중부경찰서 정상 측정 ## 7 남자 1 26 0.136 2022-07-01 00:10:00 안산상록경찰서 정상 측정 ## 8 남자 1 44 0.084 2022-07-01 00:13:00 부산사상경찰서 정상 측정 ## 9 여자 1 59 0.184 2022-07-01 00:13:00 군산경찰서 정상 측정 ## 10 남자 1 23 0.164 2022-07-01 00:13:00 대구북부경찰서 정상 측정 ## # … with 12,011 more rows 기본적으로 filter()의 인자들은 ‘and’ 조건으로 연결된다. 즉, 남자이면서 미성년자인 데이터를 뽑아내고 싶다면 다음과 같이 활용하면 된다. drunkdrive %&gt;% filter(성별 == &quot;남자&quot;, 나이 &lt; 20) ## # A tibble: 133 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 18 0.158 2022-07-02 02:56:00 천안서북경찰서 정상 측정 ## 2 남자 1 15 0.114 2022-07-02 03:51:00 공주경찰서 정상 측정 ## 3 남자 1 18 0.237 2022-07-02 23:13:00 용인서부경찰서 정상 측정 ## 4 남자 1 19 0.03 2022-07-03 02:18:00 화순경찰서 정상 측정 ## 5 남자 1 16 0.083 2022-07-03 02:19:00 서울강북경찰서 정상 측정 ## 6 남자 1 16 0.124 2022-07-03 02:40:00 천안동남경찰서 정상 측정 ## 7 남자 1 19 0.149 2022-07-03 05:18:00 밀양경찰서 정상 측정 ## 8 남자 1 19 0.049 2022-07-03 08:20:00 광주서부경찰서 정상 측정 ## 9 남자 1 17 0.045 2022-07-03 23:03:00 김해서부경찰서 정상 측정 ## 10 남자 1 19 0.07 2022-07-04 01:01:00 부천원미경찰서 정상 측정 ## # … with 123 more rows 만약 ‘or’ 조건으로 연결하고 싶다면 |를 사용하면 된다. |는 or을 의미한다. |를 사용하면 남자이거나 미성년자인 데이터를 뽑아낼 수 있다. drunkdrive %&gt;% filter(성별 == &quot;남자&quot; | 나이 &lt; 20) ## # A tibble: 10,644 × 8 ## 성별 적발횟수 나이 알콜농도 측정일시 관할경찰서 나이불명 측정 ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 남자 1 29 0.153 2022-07-01 00:00:00 아산경찰서 정상 측정 ## 2 남자 1 28 0.046 2022-07-01 00:02:00 전주덕진경찰서 정상 측정 ## 3 남자 1 61 0.047 2022-07-01 00:02:00 서울관악경찰서 정상 측정 ## 4 남자 1 66 0.139 2022-07-01 00:05:00 서울마포경찰서 정상 측정 ## 5 남자 1 31 0.214 2022-07-01 00:05:00 대전중부경찰서 정상 측정 ## 6 남자 1 26 0.136 2022-07-01 00:10:00 안산상록경찰서 정상 측정 ## 7 남자 1 44 0.084 2022-07-01 00:13:00 부산사상경찰서 정상 측정 ## 8 남자 1 23 0.164 2022-07-01 00:13:00 대구북부경찰서 정상 측정 ## 9 남자 1 33 0.17 2022-07-01 00:15:00 의왕경찰서 정상 측정 ## 10 남자 1 37 0.144 2022-07-01 00:16:00 광주북부경찰서 정상 측정 ## # … with 10,634 more rows 4.3.4 mutate() mutate() 함수는 데이터셋에 새로운 열을 추가할 때 사용한다. mutate() 함수는 기존의 열을 사용해 새로운 열을 만들 때 사용한다. mutate() 함수는 항상 데이터프레임의 마지막 열에 새로운 열을 추가한다. datatoys 패키지의 tuition 데이터셋은 한국장학재단에서 제공하는 매년 4월 대학정보공시 기준의 대학별 입학정원, 평균입학금, 평균등록금 정보 등을 제공한다. 먼저 select() 함수를 통해 필요한 데이터를 뽑고, mutate() 함수를 사용해 한 학기당 등록금을 계산해보자. 한 학기당 등록금은 평균 등록금을 2로 나눈 값이다. tuition %&gt;% select(대학명, 평균등록금.원.) %&gt;% mutate(한학기당등록금 = 평균등록금.원. / 2) ## # A tibble: 388 × 3 ## 대학명 평균등록금.원. 한학기당등록금 ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 강릉원주대학교 4261939 2130970. ## 2 강원대학교 4126501 2063250. ## 3 경남과학기술대학교 3800174 1900087 ## 4 경북대학교 4499592 2249796 ## 5 경상국립대학교 4083198 2041599 ## 6 경인교육대학교 3189000 1594500 ## 7 공주교육대학교 3424000 1712000 ## 8 공주대학교 3826015 1913008. ## 9 광주과학기술원 2060000 1030000 ## 10 광주교육대학교 3476500 1738250 ## # … with 378 more rows 또는 ‘원’ 단위의 등록금을 ‘만원’ 단위로 바꿔 볼 수도 있다. tuition %&gt;% select(대학명, 평균등록금.원.) %&gt;% mutate(평균등록금_만원 = 평균등록금.원. / 10000) %&gt;% arrange(desc(평균등록금_만원)) ## # A tibble: 388 × 3 ## 대학명 평균등록금.원. 평균등록금_만원 ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 한국공학대학교 9034616 903. ## 2 한국에너지공과대학교 9000000 900 ## 3 연세대학교 8949735 895. ## 4 추계예술대학교 8778884 878. ## 5 신한대학교 8714105 871. ## 6 이화여자대학교 8689951 869. ## 7 을지대학교 8492904 849. ## 8 한양대학교 8486720 849. ## 9 한국항공대학교 8465834 847. ## 10 성균관대학교 8381038 838. ## # … with 378 more rows 한국공학대학교의 평균 등록금이 연간 903만원으로 가장 높다. 순위를 표시하고 싶으면 row_number() 함수를 사용하면 된다. row_number() 함수는 데이터프레임의 행 번호를 표시한다. 높은 순위부터 순서대로 표시하고 싶다면 desc() 함수를 사용하면 된다. tuition %&gt;% select(대학명, 평균등록금.원.) %&gt;% mutate(평균등록금_만원 = 평균등록금.원. / 10000) %&gt;% arrange(desc(평균등록금_만원)) %&gt;% mutate(순위 = row_number(desc(평균등록금_만원))) ## # A tibble: 388 × 4 ## 대학명 평균등록금.원. 평균등록금_만원 순위 ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 한국공학대학교 9034616 903. 1 ## 2 한국에너지공과대학교 9000000 900 2 ## 3 연세대학교 8949735 895. 3 ## 4 추계예술대학교 8778884 878. 4 ## 5 신한대학교 8714105 871. 5 ## 6 이화여자대학교 8689951 869. 6 ## 7 을지대학교 8492904 849. 7 ## 8 한양대학교 8486720 849. 8 ## 9 한국항공대학교 8465834 847. 9 ## 10 성균관대학교 8381038 838. 10 ## # … with 378 more rows 4.3.4.1 ifelse()와 함께 ifelse() 함수는 조건에 따라 다른 값을 반환한다. ifelse() 함수는 mutate() 함수와 함께 사용하면 특정 조건에 따라 다른 값을 가지는 새로운 열을 만들 수 있다. ifelse() 함수는 다음과 같이 사용한다. tuition %&gt;% select(대학명, 평균등록금.원.) %&gt;% mutate(백만원 = ifelse(평균등록금.원. &gt;= 4000000, &quot;400만원 이상&quot;, &quot;400만원 미만&quot;)) ## # A tibble: 388 × 3 ## 대학명 평균등록금.원. 백만원 ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 강릉원주대학교 4261939 400만원 이상 ## 2 강원대학교 4126501 400만원 이상 ## 3 경남과학기술대학교 3800174 400만원 미만 ## 4 경북대학교 4499592 400만원 이상 ## 5 경상국립대학교 4083198 400만원 이상 ## 6 경인교육대학교 3189000 400만원 미만 ## 7 공주교육대학교 3424000 400만원 미만 ## 8 공주대학교 3826015 400만원 미만 ## 9 광주과학기술원 2060000 400만원 미만 ## 10 광주교육대학교 3476500 400만원 미만 ## # … with 378 more rows ifelse() 함수의 첫 번째 인자는 조건이다. 조건은 평균등록금.원. &gt;= 4000000으로, 평균 등록금이 400만원 이상인지 아닌지를 판단한다. 두 번째 인자는 조건이 참일 때 반환할 값이다. 세 번째 인자는 조건이 거짓일 때 반환할 값이다. ifelse() 함수는 조건이 참일 때와 거짓일 때 반환할 값의 자료형이 같아야 한다. 4.3.5 rename() rename() 함수는 열 이름을 바꿀 때 사용한다. 평균등록금.원.이란 뭔가 마음 한구석 불편한 이름을 평균등록금_원으로 바꿔보자. tuition %&gt;% select(대학명, 평균등록금.원.) %&gt;% rename( 대학이름 = 대학명, 평균등록금_원 = 평균등록금.원. ) ## # A tibble: 388 × 2 ## 대학이름 평균등록금_원 ## &lt;chr&gt; &lt;int&gt; ## 1 강릉원주대학교 4261939 ## 2 강원대학교 4126501 ## 3 경남과학기술대학교 3800174 ## 4 경북대학교 4499592 ## 5 경상국립대학교 4083198 ## 6 경인교육대학교 3189000 ## 7 공주교육대학교 3424000 ## 8 공주대학교 3826015 ## 9 광주과학기술원 2060000 ## 10 광주교육대학교 3476500 ## # … with 378 more rows 4.3.6 group_by() group_by() 함수는 데이터를 그룹으로 나눌 때 사용한다. group_by() 함수는 많은 경우 summarise() 함수와 함께 사용한다. summarise() 함수는 그룹별로 요약 통계량을 계산한다. 각 지역별로 평균 등록금을 계산해보자. tuition %&gt;% group_by(지역별) %&gt;% summarise(평균등록금_원 = mean(평균등록금.원.)) %&gt;% arrange(desc(평균등록금_원)) ## # A tibble: 17 × 2 ## 지역별 평균등록금_원 ## &lt;chr&gt; &lt;dbl&gt; ## 1 경기 6398933. ## 2 서울 5965247. ## 3 세종 5917194 ## 4 대전 5898748. ## 5 충남 5625469. ## 6 울산 5617955. ## 7 경북 5579286. ## 8 충북 5509948. ## 9 광주 5342153. ## 10 전북 5331158. ## 11 부산 5276806. ## 12 인천 5264909. ## 13 강원 5204863. ## 14 대구 5045801. ## 15 경남 4944646. ## 16 전남 4504543. ## 17 제주 4357420. n() 함수를 활용하면 그룹별로 데이터의 개수를 계산할 수 있다. 각 지역별로 몇 개의 대학이 있는지 알아보자. tuition %&gt;% group_by(지역별) %&gt;% summarise(대학수 = n()) %&gt;% arrange(desc(대학수)) ## # A tibble: 17 × 2 ## 지역별 대학수 ## &lt;chr&gt; &lt;int&gt; ## 1 경기 65 ## 2 서울 63 ## 3 경북 37 ## 4 부산 25 ## 5 충남 25 ## 6 경남 24 ## 7 전남 21 ## 8 전북 21 ## 9 강원 19 ## 10 광주 18 ## 11 충북 18 ## 12 대전 17 ## 13 대구 14 ## 14 인천 9 ## 15 울산 5 ## 16 제주 5 ## 17 세종 2 4.4 데이터라는 것이 폭발한다. 합쳤을 때. 실제 데이터 분석을 할 때 한가지 데이터만으로 분석이 진행되는 경우는 거의 없다. 일반적으로 우리가 데이터에서 답을 찾아내기 위해서는 여러 데이터들을 합쳐야 하는 경우가 많다. 이렇게 관계가 있는 데이터들을 관계형 데이터라고 하는데 각 개별 데이터셋 끼리의 관계가 중요하기 때문이다. 이 관계는 주로 키(key) 값으로 연결된다. 키는 각 데이터프레임을 연결하는데 사용되는 변수(열)을 뜻한다. 키는 주민등록번호, 학번, 이름 등이 될 수 있다. 키를 사용하여 데이터프레임을 연결하는 것을 결합(join)이라고 한다. 결합은 dplyr 패키지의 inner_join(), left_join(), right_join(), full_join() 함수를 사용한다. 4.4.1 left_join() left_join() 함수는 두 데이터프레임을 합칠 때 사용한다. left_join() 함수는 왼쪽 데이터프레임의 모든 행을 포함하는 데이터프레임을 만든다. 위에서 설명한 다른 join방법들이 있지만 별다른 이유가 없다면 left_join() 함수를 사용하자. 이는 왼쪽의 모든 관측값을 보존한다. 성적 &lt;- tibble( 이름 = c(&quot;철수&quot;, &quot;영희&quot;, &quot;영수&quot;), 토익 = c(900, 800, 700) ) 개인정보 &lt;- tibble( 이름 = c(&quot;영수&quot;, &quot;영희&quot;), 고향 = c(&quot;부산&quot;, &quot;정읍&quot;), 나이 = c(20, 21) ) 먼저 tibble() 함수를 사용해 새로운 데이터프레임을 2가지 만들었다. 성적 데이터프레임은 이름과 토익 점수를 담고 있다. 개인정보 데이터프레임은 이름, 고향, 나이를 담고 있다. left_join() 함수를 사용해 두 데이터프레임을 합쳐보자. 성적 %&gt;% left_join(개인정보, by = &quot;이름&quot;) ## # A tibble: 3 × 4 ## 이름 토익 고향 나이 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 철수 900 &lt;NA&gt; NA ## 2 영희 800 정읍 21 ## 3 영수 700 부산 20 그 결과 성적 데이터프레임의 모든 행이 포함된 데이터프레임이 만들어졌다. left_join() 함수는 왼쪽 데이터셋의 값을 보존하기 때문에 왼쪽 데이터셋에 없는 키 값은 결측값으로 처리된다. 성적 데이터프레임에 없는 이름인 “철수”의 고향과 나이는 결측값으로 처리된다. 만약 개인정보를 먼저 입력했다면 모든 관측값이 보존되었을 것이다. 개인정보 %&gt;% left_join(성적, by = &quot;이름&quot;) ## # A tibble: 2 × 4 ## 이름 고향 나이 토익 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 영수 부산 20 700 ## 2 영희 정읍 21 800 by = 인자는 결합할 때 사용할 키를 지정한다. 만약 지정되지 않았다면 두 데이터프레임에 공통된 열 이름을 키로 사용한다. by = 인자에 키가 여러 개인 경우에는 c() 함수를 사용해 여러 개의 키를 지정한다. 만약 철수라는 동명이인이 여러명 존재한다고 해보자. 성적 &lt;- tibble( 이름 = c(&quot;철수&quot;, &quot;영희&quot;, &quot;영수&quot;, &quot;철수&quot;, &quot;철수&quot;), 학번 = c(1, 2, 3, 4, 5), 토익 = c(900, 800, 700, 450, 100) ) 개인정보 &lt;- tibble( 이름 = c(&quot;영수&quot;, &quot;영희&quot;, &quot;철수&quot;, &quot;철수&quot;, &quot;철수&quot;), 학번 = c(3, 2, 1, 4, 5), 고향 = c(&quot;부산&quot;, &quot;정읍&quot;, &quot;서울&quot;, &quot;평양&quot;, &quot;뉴욕&quot;), 나이 = c(20, 21, 22, 23, 24) ) 성적 %&gt;% left_join(개인정보, by = c(&quot;이름&quot;, &quot;학번&quot;)) ## # A tibble: 5 × 5 ## 이름 학번 토익 고향 나이 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 철수 1 900 서울 22 ## 2 영희 2 800 정읍 21 ## 3 영수 3 700 부산 20 ## 4 철수 4 450 평양 23 ## 5 철수 5 100 뉴욕 24 결과적으로 이름과 학번이 모두 일치한 데이터를 join한다. 만약 키가 되는 열 이름이 서로 다른 경우에는 어떻게 할까? 그러 때는 by = 인자에 왼쪽 데이터프레임의 키와 오른쪽 데이터프레임의 키를 지정할 수 있다. 성적 &lt;- tibble( 이름 = c(&quot;철수&quot;, &quot;영희&quot;, &quot;영수&quot;), 토익 = c(900, 800, 700) ) 개인정보 &lt;- tibble( name = c(&quot;영수&quot;, &quot;영희&quot;, &quot;철수&quot;), 고향 = c(&quot;부산&quot;, &quot;정읍&quot;, &quot;서울&quot;), 나이 = c(20, 21, 22) ) 성적 %&gt;% left_join(개인정보, by = c(&quot;이름&quot; = &quot;name&quot;)) ## # A tibble: 3 × 4 ## 이름 토익 고향 나이 ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 철수 900 서울 22 ## 2 영희 800 정읍 21 ## 3 영수 700 부산 20 "],["시각화-기초.html", "챕터 5 시각화 기초 5.1 이왕이면 예쁜 그래프 5.2 시각화 요소", " 챕터 5 시각화 기초 데이터 시각화는 데이터를 시각적으로 표현하여 이를 이해하고 전달하는 데에 사용된다. 숫자로만 이뤄진 복잡한 데이터를 직관적이고 효과적으로 분석할 수 있으며, 트렌드, 패턴, 상관 관계 등을 시각적으로 파악할 수 있다. 이런 시각화는 데이터를 보다 직관적으로 이해할 수 있도록 하여 데이터를 통한 의사소통을 원활하게 할 수 있다. 시각화는 결국 ‘효과적인 정보 전달’이 목적인데 그러기 위해서는 사람의 인지방식에 대한 이해 또한 필요하다. 한마디로 데이터 시각화란 데이터에서 찾은 인사이트를 사람이 쉽게 인지할 수 있게 표현하는 방법이다. 여기 앤스컴 콰르탯이라는 데이터가 존재한다(datasets 패키지에 내장되어 있다). 영국의 통계학자인 Frank Anscombe이 만든 데이터셋들로 X1~X4, Y1~Y4까지 데이터가 존재하며 각각 숫자에 맞는 X와 Y값은 매칭되는 총 4개의 그룹에 각각 11개의 관측값이 존재하는 데이터다. knitr::kable(anscombe) x1 x2 x3 x4 y1 y2 y3 y4 10 10 10 8 8.04 9.14 7.46 6.58 8 8 8 8 6.95 8.14 6.77 5.76 13 13 13 8 7.58 8.74 12.74 7.71 9 9 9 8 8.81 8.77 7.11 8.84 11 11 11 8 8.33 9.26 7.81 8.47 14 14 14 8 9.96 8.10 8.84 7.04 6 6 6 8 7.24 6.13 6.08 5.25 4 4 4 19 4.26 3.10 5.39 12.50 12 12 12 8 10.84 9.13 8.15 5.56 7 7 7 8 4.82 7.26 6.42 7.91 5 5 5 8 5.68 4.74 5.73 6.89 나열된 숫자만을 읽는 것은 매우 피곤한일인지라, 먼저 데이터의 평균과 분산을 한번 계산해보자(코드의 해석은 생각하지 말고 결과값에 집중해보자). # 평균 계산 lapply(anscombe, mean) ## $x1 ## [1] 9 ## ## $x2 ## [1] 9 ## ## $x3 ## [1] 9 ## ## $x4 ## [1] 9 ## ## $y1 ## [1] 7.500909 ## ## $y2 ## [1] 7.500909 ## ## $y3 ## [1] 7.5 ## ## $y4 ## [1] 7.500909 # 분산 계산 lapply(anscombe, var) ## $x1 ## [1] 11 ## ## $x2 ## [1] 11 ## ## $x3 ## [1] 11 ## ## $x4 ## [1] 11 ## ## $y1 ## [1] 4.127269 ## ## $y2 ## [1] 4.127629 ## ## $y3 ## [1] 4.12262 ## ## $y4 ## [1] 4.123249 X1~X4 모두 평균 9, 분산 11로 동일했으며, Y1~Y4 에서도 평균 7.5 분산 4.12로 동일했다. cor(anscombe) ## x1 x2 x3 x4 y1 y2 y3 y4 ## x1 1.0000000 1.0000000 1.0000000 -0.5000000 0.8164205 0.8162365 0.8162867 -0.3140467 ## x2 1.0000000 1.0000000 1.0000000 -0.5000000 0.8164205 0.8162365 0.8162867 -0.3140467 ## x3 1.0000000 1.0000000 1.0000000 -0.5000000 0.8164205 0.8162365 0.8162867 -0.3140467 ## x4 -0.5000000 -0.5000000 -0.5000000 1.0000000 -0.5290927 -0.7184365 -0.3446610 0.8165214 ## y1 0.8164205 0.8164205 0.8164205 -0.5290927 1.0000000 0.7500054 0.4687167 -0.4891162 ## y2 0.8162365 0.8162365 0.8162365 -0.7184365 0.7500054 1.0000000 0.5879193 -0.4780949 ## y3 0.8162867 0.8162867 0.8162867 -0.3446610 0.4687167 0.5879193 1.0000000 -0.1554718 ## y4 -0.3140467 -0.3140467 -0.3140467 0.8165214 -0.4891162 -0.4780949 -0.1554718 1.0000000 X와 매칭되는 Y의 상관계수는 각각 0.816으로 동일했으며 1차 회귀식은 모두 y = 3 + 0.5x로 동일했다. 즉 4개 그룹의 평균, 분산, 상관계수 및 회귀식이 모두 같다. 이것만 보면 같은 경향을 가진 데이터로 볼 수 있을 것이다. 하지만 이 데이터들을 산포도 표시하면 어떤 결과가 나타날까? 역시 코드의 해석은 생각하지 말고 결과값에 집중해보자. par(mfrow = c(2, 2)) # 그래프를 2x2 그리드로 배치 # 첫 번째 그래프 plot(anscombe$x1, anscombe$y1, main = &quot;Group I&quot;, xlab = &quot;x&quot;, ylab = &quot;y&quot;) # 두 번째 그래프 plot(anscombe$x2, anscombe$y2, main = &quot;Group II&quot;, xlab = &quot;x&quot;, ylab = &quot;y&quot;) # 세 번째 그래프 plot(anscombe$x3, anscombe$y3, main = &quot;Group III&quot;, xlab = &quot;x&quot;, ylab = &quot;y&quot;) # 네 번째 그래프 plot(anscombe$x4, anscombe$y4, main = &quot;Group IV&quot;, xlab = &quot;x&quot;, ylab = &quot;y&quot;) 각 그룹은 평균, 분산, 상관관계, 회귀선 등의 통계적 속성이 거의 동일하지만 시각화해보면 각 그룹이 실제로 매우 다른 패턴을 갖고 있음을 알 수 있다. 시각적인 표현은 복잡한 데이터를 이해하기 쉽고 직관적으로 만들어준다. 앤스컴 콰르탯 데이터셋을 예시로 들어 설명했지만, 실제 데이터에서도 시각화를 통해 통찰력을 얻고 결정을 내릴 수 있을 것이다. 다음은 데이터 시각화를 하는 대표적인 이유들이다. 패턴 식별: 데이터 시각화는 데이터의 패턴을 식별하는 데 도움이 된다. 이렇게 패턴을 인식하는 것은 데이터를 이해하고 향후 분석에 활용하는 데 중요하다. 이상치 탐지: 데이터 시각화는 이상치를 탐지하는 데 유용하다. 이상치는 데이터셋에서 일반적인 패턴과 다른 값을 가진 데이터 포인트를 의미하는데, 앤스컴 콰르탯 데이터셋의 경우, 그룹 3의 x = 13, y = 12.74와 같은 값이나 그룹 4에서 x = 19, y = 12.50과 같은 이상치를 쉽게 식별할 수 있다. 이렇게 이상치를 시각적으로 확인하면 데이터의 신뢰성과 정확성을 평가할 수 있다. 상관관계 이해: 데이터 시각화는 변수 간의 상관관계를 시각적으로 이해하는 데 도움이 된다. 앤스컴 콰르탯 데이터셋의 그룹 1의 경우 x와 y의 관계가 비선형적이고 종 모양의 패턴을 보여주고, 그룹 2를 보면 선형적인 상관관계가 있음을 쉽게 알 수 있다. 이러한 상관관계를 시각화하여 변수 간의 관계를 파악하면 추세를 예측하고 의사 결정을 내릴 수 있다. 5.1 이왕이면 예쁜 그래프 같은 값이면 다홍치마 – 우리속담 심미적 사용성 효과(Aesthetic-Usability Effect)에 따르면, 심미적인 디자인은 사람들의 두뇌에 긍정적인 반응을 불러일으키고 디자인이 실제로 더 잘 작동한다고 믿게 만든다고 한다. 심미적인 디자인은 데이터의 패턴과 관계를 뚜렷하게 시각화하여 전달력을 강화한다. 그래프의 색상, 레이아웃, 텍스트의 크기와 스타일 등을 조절하여 데이터의 중요한 부분을 강조하거나, 시각적인 잡음을 최소화 함으로 보는이가 데이터의 핵심 메시지를 빠르게 파악하고 이해하는 데 도움을 줄 수 있다. 심미적인 데이터 시각화는 창의성과 상상력을 자극하기도 한다. 예술적인 요소를 활용한 시각화는 데이터에 새로운 시각을 부여함으로 새로운 통찰력을 발견할 수 있게 한다. 무엇보다 예쁜 디자인은 사람들의 관심을 끌어 더 많은 사람들에게 도달하고 공유될 수 있다. 어색하게 느껴질 수 도 있지만 데이터 시각화를 위해서는 심리학과 인문학이 중요하다. 바로 사람이 어떻게 세상을 보고 해석하는지에 대한 깊은 이해를 기반으로 한다는 공통점이 있기 때문이다. UX 디자인 분야로 생각할 수도 있겠지만 Jon Yablonski가 제작한 Law of UX 웹페이지에는 사용자 경험 디자인과 관련된 심리학적 이론을 수집하여 매력적인 디자인 방법을 소개한다. 5.2 시각화 요소 library(datatoys) library(tidyverse) 5.2.1 색상(Color) 적절한 색상 선택은 데이터의 구분과 패턴을 강조할 수 있다. 하지만 종종 시각화를 단순히 멋지게 보이게 하려는 목적으로 여러가지 색상을 사용하는 경우가 있는데, 분명한 목적이나 의도가 없이 색을 사용하지 않으면 오히려 혼란만 불러일으킬 수 있다. 마포구 반려동물 이름 순위를 시각화한 아래 두 그래프를 비교해보자. A의 경우 알록달록하니 예쁘긴 하지만 색이 무엇을 의미하는지 한번 더 들여보게 된다. 반면에 B는 조금 투박해 보일수도 있지만 전달하고자 하는 정보가 정확히 전달되는 데 아무 문제가 없다. 특별한 이유가 없다면 최대한 적은 색상을 사용해 안그래도 복잡한 이 세상에서 보는이의 피로감을 조금이나마 감소시켜 주자. 카테고리 별로 다른 색을 사용하면 보는이가 직관적으로 차이를 감지하게 된다. 또는 강조하고 싶은 곳에 특별한 색을 사용할 수도 있다. 한국방송통신대학교가 압도적인 입학정원을 보인다. 5.2.2 글씨(Text) 글씨 크기, 글씨체, 굵기, 색상 등을 조절하여 시각화의 의도를 더욱 명확하게 전달할 수 있다. 5.2.3 배치(Layout) 정렬 방식, 여백, 배경 등을 조절하여 시각화의 의도를 더욱 명확하게 전달할 수 있다. 5.2.4 그 외 요소들 시각화의 의도를 더욱 명확하게 전달할 수 있는 다양한 요소들이 존재한다. 예를 들어, 시각화의 주제와 관련된 아이콘을 추가하거나, 시각화의 주제와 관련된 배경을 추가할 수도 있다. "],["시각화.html", "챕터 6 시각화 6.1 ggplot2 소개 6.2 ggplot2 기본 문법 6.3 데이터셋과 좌표계 지정하기 6.4 ggplot2 themes", " 챕터 6 시각화 6.1 ggplot2 소개 R에서 사용할 수 있는 많은 시각화 패키지가 존재하지만, 여기서는 Hadley Wickham이 개발한 ggplot2 패키지 위주로 설명하고자 한다. ggplot2 문법은 데이터 시각화를 위한 매우 직관적이고 일관된 방법을 제공하여 사용자가 효율적으로 그래프를 생성하고 사용자 지정할 수 있도록 도와준다. 무엇보다 ggplot2는 다른 tidyverse 패키지와의 호환성이 뛰어나며, 많은 사용자 기반으로 풍부한 문서와 예제를 제공하여 사용자들이 학습하고 사용할 수 있다. 본 챕터에서는 ggplot2을 통해 데이터셋을 지정하고, 어떤 변수를 x축 또는 y축에 매핑할 것인지, 어떤 유형의 그래프를 그릴 것인지, 색상, 크기, 선 스타일 등의 추가적인 매개 변수를 설정하는 방법을 알아보도록 하자. 그 전에 R 그래프 갤러리에 접속하면 R로 만들 수 있는 대부분의 시각화 결과물들과 그 코드를 볼 수 있다. ggplot2 패키지를 사용하기 위해서는 먼저 패키지를 설치하고 불러와야 한다. ggplot2는 tidyverse 패키지에 포함되어 있으므로 tidyverse 패키지를 불러오면 ggplot2도 함께 불러와진다. library(ggplot2) 6.2 ggplot2 기본 문법 ggplot2의 기본 문법은 다음과 같다. 지금은 이 문법을 외우는 것보다는 어떤 요소들이 존재하는지를 파악하는 것에 집중하자. ggplot(data = &lt;DATA&gt;) + &lt;geom_*&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; ggplot() 함수는 데이터셋을 지정한다. + 기호는 ggplot2에서 여러 개의 레이어를 추가할 때 사용한다. aes() 함수는 데이터셋의 변수를 x축 또는 y축에 매핑한다. 이는 x축만 존재할 수도 있고, y축만 존재할 수도 있다. x축과 y축 모두 존재할 수도 있다. color =, fill =, size =, shape =, linetype = 등의 매개 변수를 사용하여 group 별 색상, 크기, 선 스타일 등을 지정할 수 있다. geom_*() 함수는 데이터셋을 어떤 유형의 그래프로 그릴 것인지를 지정한다. geom_*() 함수는 geom_point(), geom_line(), geom_bar(), geom_boxplot() 등이 있다. stat 매개 변수는 데이터를 어떻게 요약할 것인지를 지정한다. 예를 들어, geom_bar() 함수를 사용할 때 stat = \"identity\"를 지정하면 데이터셋의 값을 그대로 표현하고, stat = \"count\"를 지정하면 데이터셋의 값을 개수로 표현한다. position 매개 변수는 데이터를 어떻게 배치할 것인지를 지정한다. 예를 들어, geom_bar() 함수를 사용할 때 position = \"dodge\"를 지정하면 데이터를 그룹별로 나누어 표현하고, position = \"fill\"을 지정하면 데이터를 비율로 표현한다. coord_*() 함수는 좌표계를 지정한다. coord_*() 함수는 coord_flip(), coord_polar() 등이 있다. facet_*() 함수는 그래프를 여러 개의 패널로 나누어 표현한다. facet_*() 함수는 facet_wrap(), facet_grid() 등이 있다. 6.3 데이터셋과 좌표계 지정하기 ggplot2를 사용하기 위해서는 먼저 데이터셋을 지정해야 한다. datatoys의 petNames 데이터셋은 마포구 반려동물 이름 통계를 제공한다. 이 데이터셋을 사용하여 ggplot2를 사용해보자. library(datatoys) library(ggplot2) top10 &lt;- petNames %&gt;% arrange(desc(건수)) %&gt;% slice(1:10) 먼저 petNames 데이터셋을 건수 변수를 기준으로 내림차순 정렬하고, 상위 10개의 데이터만 추출하여 top10 데이터셋을 생성하였다. 이제 top10 데이터셋을 사용하여 ggplot2를 사용해보자. ggplot(data = top10) 만약 빈 화면만 뜬다면 정확히 한 것이다. 여기에 aes() 함수를 사용하여 x 매개 변수에 동물이름 변수를 매핑하면 x축에 동물이름 변수를 표현할 수 있다. ggplot(data = top10, aes(x = 동물이름)) 이번에는 y축에 건수 변수를 매핑해보자. ggplot(data = top10, aes(x = 동물이름, y = 건수)) +를 사용하여 geom_col() 함수를 추가하면 막대 그래프를 그릴 수 있다. 앞서 ggplot() 함수를 이용해 지정한 좌표계 위에 레이어를 쌓는 것이다. ggplot(data = top10, aes(x = 동물이름, y = 건수)) + geom_col() 막대그래프를 통해 각 동물 이름별로 반려동물 등록 건수를 확인할 수 있지만, 정확한 값을 확인하기 어렵다. 이를 해결하기 위해서는 geom_text()를 사용해 새로운 레이어를 추가해준다. geom_col() 다음에 위치하는 것을 주목하라. ggplot(data = top10, aes(x = 동물이름, y = 건수)) + geom_col() + geom_text(aes(label = 건수)) 기본적으로 ggplot2는 레이어(layer; 층)를 쌓으면서 그래프를 그린다. 이는 마치 투명한 셀로판지에 그린 그림 여러 장을 쌓는 것과 유사하다. 이때, 먼저 그린 그림이 아래에 위치하고, 나중에 그린 그림이 위에 위치한다. 이를 통해 먼저 그린 그림이 가려지지 않고, 나중에 그린 그림이 가려지는 효과를 얻을 수 있다. ggplot(data = top10, aes(x = 동물이름, y = 건수)) + geom_text(aes(label = 건수)) + geom_col() 위 그래프와 순서만 바꿨을 뿐인데 geom_text()의 결과가 일부 보이지 않는다. 이는 그 위에 쌓여진 geom_col() 함수가 그린 결과물이 geom_text() 함수의 결과물을 가려버렸기 때문이다. 다시 원래대로 순서를 바꿔주고, vjust = 매개 변수를 사용하여 텍스트의 위치를 조정해 보자. 보다 보기 좋아질 것이다. ggplot(data = top10, aes(x = 동물이름, y = 건수)) + geom_col() + geom_text(aes(label = 건수), vjust = -0.5) coord_flip() 함수를 사용하면 x축과 y축을 바꿀 수 있다. geom_text() 함수의 vjust = 매개 변수가 hjust =로 바뀐 것은 coord_flip() 함수를 사용하면 x축과 y축이 바뀌기 때문이다. ggplot(data = top10, aes(x = 동물이름, y = 건수)) + geom_col() + geom_text(aes(label = 건수), hjust = -0.5) + coord_flip() coord_* 함수는 좌표계를 지정하는 함수이다. coord_flip() 함수는 좌표계를 수평으로 뒤집는다. coord_polar() 함수는 좌표계를 극좌표계로 변환한다. coord_* 계열 함수에는 coord_cartesian(), coord_fixed(), coord_map() 등이 있다. ggplot(data = top10, aes(x = 동물이름, y = 건수)) + geom_col() + geom_text(aes(label = 건수)) + coord_polar() 만약 우리만 이 그래프를 볼 목적이라면 상관 없겠지만, 아무것도 모르는 사람이 이 그래프를 보면 무슨 의미인지 알 수 없다. labs() 함수를 사용하면 그래프의 제목(title), 부제목(subtitle), 캡션(caption), x축과 y축의 이름을 지정할 수 있다. 그래프에 대한 설명을 추가해 보다 뜻을 명확하게 해 보자. ggplot(data = top10, aes(x = 동물이름, y = 건수)) + geom_col() + geom_text(aes(label = 건수), hjust = -0.5) + coord_flip() + labs( title = &quot;마포구 반려동물 이름 통계&quot;, subtitle = &quot;상위 10개의 반려동물 이름&quot;, caption = &quot;데이터 출처: 마포구청&quot;, x = &quot;반려동물 이름&quot;, y = &quot;등록 건수&quot; ) 보다 명확한 그래프를 만들었다. 충분히 아름다운 그래프지만 그래프에서 아쉬운 점을 하나 찾아본다면 막대그래프의 순서이다. 큰 순서부터, 또는 작은 순서부터 보여주는 방법은 없을까? reorder() 함수를 사용하면 막대그래프의 순서를 변경할 수 있다. reorder(x, y) 함수는 x 매개 변수에 지정한 변수를 y 매개 변수에 지정한 변수의 크기에 따라 재정렬한다. -를 사용하면 내림차순으로 정렬한다. ggplot(data = top10, aes(x = reorder(동물이름, 건수), y = 건수)) + geom_col() + geom_text(aes(label = 건수), hjust = -0.5) + coord_flip() + labs( title = &quot;마포구 반려동물 이름 통계&quot;, subtitle = &quot;상위 10개의 반려동물 이름&quot;, caption = &quot;데이터 출처: 마포구청&quot;, x = &quot;반려동물 이름&quot;, y = &quot;등록 건수&quot; ) 6.4 ggplot2 themes ggplot2는 기본적으로 흰색 배경에 회색 격자를 그리는데, 이를 변경할 수 있다. theme_*() 함수를 사용하여 테마를 변경할 수 있다. ggthemes 패키지를 통해 다양한 추가 테마를 사용할 수 있다. library(ggthemes) ggplot(data = top10, aes(x = reorder(동물이름, 건수), y = 건수)) + geom_col() + geom_text(aes(label = 건수), hjust = -0.5) + coord_flip() + labs( title = &quot;마포구 반려동물 이름 통계&quot;, subtitle = &quot;상위 10개의 반려동물 이름&quot;, caption = &quot;데이터 출처: 마포구청&quot; ) + theme_fivethirtyeight(base_family = &quot;NanumGothic&quot;) "],["호선-지하철-혼잡도-분석.html", "챕터 7 2호선 지하철 혼잡도 분석", " 챕터 7 2호선 지하철 혼잡도 분석 서울 지하철은 붐빈다. 자리도 없고 혼잡한 승차 시간엔 더 불편하다. 하지만, 이를 피하기 위한 작은 전략들이 있다. 아주 일찍 나가거나 늦게 가는 방법이다. 그렇다면 ‘정확히’ 어느 시간에 가면될까? 마침 datatoys패키지에는 busyMetro데이터셋이 내장되어있다. 이는 서울교통공사 1-8호선 30분 단위 평균 혼잡도로 30분간 지나는 열차들의 평균 혼잡도(정원대비 승차인원)를 의미한다. library(tidyverse) library(datatoys) str(busyMetro) ## Warning in str(busyMetro): restarting interrupted promise evaluation ## tibble [64,662 × 7] (S3: tbl_df/tbl/data.frame) ## $ 요일구분: chr [1:64662] &quot;평일&quot; &quot;평일&quot; &quot;평일&quot; &quot;평일&quot; ... ## $ 호선 : int [1:64662] 1 1 1 1 1 1 1 1 1 1 ... ## $ 역번호 : int [1:64662] 150 150 150 150 150 150 150 150 150 150 ... ## $ 출발역 : chr [1:64662] &quot;서울역&quot; &quot;서울역&quot; &quot;서울역&quot; &quot;서울역&quot; ... ## $ 상하구분: chr [1:64662] &quot;상선&quot; &quot;상선&quot; &quot;상선&quot; &quot;상선&quot; ... ## $ 시간 : Factor w/ 39 levels &quot;5:30&quot;,&quot;6:00&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... ## $ 혼잡도 : num [1:64662] 7.3 18.1 18.1 30.9 56.6 69.1 82.7 57.5 52.3 36.9 ... 먼저 시간별로 전체 지하철의 혼잡도를 살펴보자. busyMetro %&gt;% group_by(시간) %&gt;% summarise(평균혼잡도 = mean(혼잡도, na.rm = TRUE)) ## # A tibble: 39 × 2 ## 시간 평균혼잡도 ## &lt;fct&gt; &lt;dbl&gt; ## 1 5:30 14.8 ## 2 6:00 14.7 ## 3 6:30 14.3 ## 4 7:00 18.6 ## 5 7:30 24.5 ## 6 8:00 32.1 ## 7 8:30 30.0 ## 8 9:00 29.3 ## 9 9:30 27.7 ## 10 10:00 25.6 ## # … with 29 more rows 혼잡도를 그래프로 나타내 보면 다음과 같다. geom_line() 함수 안에 aes(group = 1)을 추가하여 모든 데이터 요소를 하나의 그룹으로 처리할 수 있다. busyMetro %&gt;% group_by(시간) %&gt;% summarise(평균혼잡도 = mean(혼잡도, na.rm = TRUE)) %&gt;% ggplot(aes(시간, 평균혼잡도)) + geom_line(aes(group = 1)) + labs(title = &quot;서울교통공사 지하철 시간대별 평균 혼잡도&quot;, subtitle = &quot;평일 05:30 ~ 00:30&quot;) 화면비율이나 크기에 따라 다르겠지만, x축의 시간 변수가 겹쳐보인다. 이를 해결하기 위해 x축의 글자들을 45도 회전시켜보자.theme() 함수 안에 axis.text.x = element_text(angle = 45, hjust = 1)을 추가하면 된다. hjust =를 사용해서 높이를 약간 조절해준다. busyMetro %&gt;% group_by(시간) %&gt;% summarise(평균혼잡도 = mean(혼잡도, na.rm = TRUE)) %&gt;% ggplot(aes(시간, 평균혼잡도)) + geom_line(aes(group = 1)) + labs(title = &quot;서울교통공사 지하철 시간대별 평균 혼잡도&quot;, subtitle = &quot;평일 05:30 ~ 00:30&quot;) + theme(axis.text.x = element_text(angle = 45, hjust = 1)) 확실히 출근시간과 퇴근시간 대에 피크를 볼 수 있다. 그렇다면 평일과 주말의 양상은 어떻게 다를까? geom_line() 함수 안에 aes(color = 요일구분)을 추가하면 요일별로 색상을 다르게 표현할 수 있다. scale_color_manual() 함수를 이용해 색상을 직접 지정할 수도 있다. busyMetro %&gt;% group_by(요일구분, 시간) %&gt;% summarise(평균혼잡도 = mean(혼잡도, na.rm = TRUE)) %&gt;% ggplot(aes(시간, 평균혼잡도)) + geom_line(aes(group = 요일구분, color = 요일구분)) + scale_color_manual(values = c(&quot;#E966A0&quot;, &quot;#213363&quot;, &quot;#8EAC50&quot;)) + labs(title = &quot;서울교통공사 지하철 시간대별 평균 혼잡도&quot;, subtitle = &quot;평일 05:30 ~ 00:30&quot;) + theme(axis.text.x = element_text(angle = 45, hjust = 1)) ## `summarise()` has grouped output by &#39;요일구분&#39;. You can override using the `.groups` argument. ## Warning: Removed 4 rows containing missing values (`geom_line()`). ## Warning: Removed 4 rows containing missing values geom_line().라는 경고문구가 나타난다. 주말이나 공휴일에는 지하철 운행시간이 달라 데이터가 존재하지 않기 때문이다. legend 위치를 조절하기 위해서는 theme() 함수 안에 legend.position =을 추가하면 된다. busyMetro %&gt;% group_by(요일구분, 시간) %&gt;% summarise(평균혼잡도 = mean(혼잡도, na.rm = TRUE)) %&gt;% ggplot(aes(시간, 평균혼잡도)) + geom_line(aes(group = 요일구분, color = 요일구분)) + scale_color_manual(values = c(&quot;#E966A0&quot;, &quot;#213363&quot;, &quot;#8EAC50&quot;)) + labs(title = &quot;서울교통공사 지하철 시간대별 평균 혼잡도&quot;, subtitle = &quot;평일 05:30 ~ 00:30&quot;) + theme( axis.text.x = element_text(angle = 45, hjust = 1), legend.position = &quot;bottom&quot; ) ## `summarise()` has grouped output by &#39;요일구분&#39;. You can override using the `.groups` argument. ## Warning: Removed 4 rows containing missing values (`geom_line()`). 이번에는 호선별로 평일 지하철 혼잡도를 살펴보자. facet_wrap() 함수를 이용하면 호선별로 그래프를 나눌 수 있다. facet_wrap() 함수 안에 . ~호선을 추가하면 호선별로 그래프를 나눌 수 있다. strip.position = \"bottom\"을 추가하면 그래프의 하단에 호선명이 나타난다. busyMetro %&gt;% filter(요일구분 == &quot;평일&quot;) %&gt;% group_by(호선, 시간) %&gt;% summarise(평균혼잡도 = mean(혼잡도, na.rm = TRUE)) %&gt;% ggplot(aes(시간, 평균혼잡도)) + geom_line(aes(group = 1)) + facet_wrap(. ~호선, ncol = 2, strip.position = &quot;top&quot;) + labs(title = &quot;서울교통공사 지하철 시간대별 혼잡도&quot;, subtitle = &quot;평일 05:30 ~ 00:30&quot;) + theme(axis.text.x = element_text(angle = 45, hjust = 1)) ## `summarise()` has grouped output by &#39;호선&#39;. You can override using the `.groups` argument. 가장 붐비는 지하철 역은 어딜까? very_busy &lt;- busyMetro %&gt;% filter(요일구분 == &quot;평일&quot;) %&gt;% group_by(출발역, 상하구분) %&gt;% summarise(평균혼잡도 = mean(혼잡도, na.rm = TRUE)) %&gt;% arrange(desc(평균혼잡도)) %&gt;% head(20) ## `summarise()` has grouped output by &#39;출발역&#39;. You can override using the `.groups` argument. very_busy ## # A tibble: 20 × 3 ## # Groups: 출발역 [13] ## 출발역 상하구분 평균혼잡도 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 방배 내선 58.1 ## 2 교대 내선 57.6 ## 3 서초 내선 57.5 ## 4 석촌 하선 56.4 ## 5 송파 상선 55.8 ## 6 강남 내선 55.7 ## 7 송파 하선 54.6 ## 8 사당 내선 54.4 ## 9 서초 외선 54.0 ## 10 사당 외선 53.8 ## 11 방배 외선 53.5 ## 12 교대 외선 53.2 ## 13 어린이대공원 하선 52.4 ## 14 건대입구 상선 52.0 ## 15 잠실 하선 51.8 ## 16 낙성대 내선 51.8 ## 17 문정 상선 51.5 ## 18 석촌 상선 51.5 ## 19 어린이대공원 상선 51.0 ## 20 역삼 내선 50.9 평일 평균 혼잡도가 가장 높은 상위 20개 역을 선정하였다. 그럼 각 역의 시간대별 혼잡도를 살펴보자. filter() 함수를 이용해 평일 데이터만 추출하고, mutate() 함수를 이용해 출발역 변수를 생성한다. paste() 함수를 이용해 호선, 상하구분과 출발역을 붙여주었다. facet_wrap() 함수를 이용해 출발역별로 그래프를 나누었다. element_blank()를 사용하면 축의 텍스트를 제거할 수 있다. very_busy %&gt;% select(출발역, 상하구분) %&gt;% left_join(busyMetro, by = c(&quot;출발역&quot;, &quot;상하구분&quot;)) %&gt;% filter(요일구분 == &quot;평일&quot;) %&gt;% mutate(출발역 = paste(호선, &quot;호선&quot;, 출발역, 상하구분)) %&gt;% ggplot(aes(시간, 혼잡도, color = 상하구분)) + geom_line(aes(group = 상하구분)) + facet_wrap(. ~출발역, ncol = 5, strip.position = &quot;bottom&quot;) + labs( title = &quot;서울교통공사 지하철 시간대별 혼잡도&quot;, subtitle = &quot;상위 20개 역; 평일 05:30 ~ 00:30&quot; ) + theme(axis.text.x = element_blank()) 평일 붐비는 지하철이 싫다면, 저 시간대를 피하거나 다른 경로를 이용해 보는건 어떨까? "],["손없는-날-판별하기-함수.html", "챕터 8 손없는 날 판별하기 (함수) 8.1 map() 함수", " 챕터 8 손없는 날 판별하기 (함수) 손없는 날(損-)에서의 손은 사람의 활동을 방해하고 사람에게 해코지 한다는 악귀 또는 악신을 뜻하며, 나쁜 귀신이 돌아다니지 않아 인간에게 해를 끼치치 않는 길한 날을 의미한다. 음력 날짜로는 9와 0[1]으로 끝나는 날이며, 8개의 모든 방향으로 귀신이 활동하지 않는 길일이다. 따라서 이날에 수리, 이사, 혼례, 개업 등을 하면 상서롭다고 믿으며 주요행사의 날짜를 정하는 기준이 된다. datatoys의 Kcalendar 데이터셋에서는 한국천문연구원에서 제공하는 날짜와 관련된 다양한 데이터를 제공한다. 이 중 날짜 별 손없는 날을 제공하는데, 손없는 날을 찾는 간단한 함수를 한번 만들어보자. 먼저 데이터는 아래와 같다. library(datatoys) library(dplyr) str(Kcalendar) ## tibble [241,027 × 11] (S3: tbl_df/tbl/data.frame) ## $ 양력날짜 : Date[1:241027], format: &quot;1391-02-05&quot; &quot;1391-02-06&quot; &quot;1391-02-07&quot; &quot;1391-02-08&quot; ... ## $ 음력날짜 : Date[1:241027], format: &quot;1391-01-01&quot; &quot;1391-01-02&quot; &quot;1391-01-03&quot; &quot;1391-01-04&quot; ... ## $ 음력간지년한글: chr [1:241027] &quot;신미&quot; &quot;신미&quot; &quot;신미&quot; &quot;신미&quot; ... ## $ 음력간지월한글: chr [1:241027] &quot;경인&quot; &quot;경인&quot; &quot;경인&quot; &quot;경인&quot; ... ## $ 음력간지일한글: chr [1:241027] &quot;기축&quot; &quot;경인&quot; &quot;신묘&quot; &quot;임진&quot; ... ## $ 음력간지년한자: chr [1:241027] &quot;辛未&quot; &quot;辛未&quot; &quot;辛未&quot; &quot;辛未&quot; ... ## $ 음력간지월한자: chr [1:241027] &quot;庚寅&quot; &quot;庚寅&quot; &quot;庚寅&quot; &quot;庚寅&quot; ... ## $ 음력간지일한자: chr [1:241027] &quot;己丑&quot; &quot;庚寅&quot; &quot;辛卯&quot; &quot;壬辰&quot; ... ## $ 율리우스적일 : num [1:241027] 2229156 2229157 2229158 2229159 2229160 ... ## $ 손없는날 : logi [1:241027] FALSE FALSE FALSE FALSE FALSE FALSE ... ## $ 손있는날 : chr [1:241027] &quot;동&quot; &quot;동&quot; &quot;남&quot; &quot;남&quot; ... 손없는날을 찾는 함수를 만들어보자. find_son &lt;- function(date) { son &lt;- datatoys::Kcalendar %&gt;% filter(양력날짜 == date) %&gt;% pull(손없는날) return(son) } find_son(date = &quot;2024-01-01&quot;) ## [1] TRUE find_son(date = &quot;2024-01-02&quot;) ## [1] FALSE 임의의 날짜를 입력하면 손없는 날인지 아닌지를 판별해주는 함수를 만들었다. 하지만 TRUE 또는 FALSE로 표현되는 함수는 보기 친절하지 않다. 손없는 날이면 “손없는 날입니다.”라는 메시지를, 손없는 날이 아니면 “손없는 날이 아닙니다.”라는 메시지를 출력하는 함수를 만들어보자. if() 함수를 이용해 손없는 날인지 아닌지를 판별하고, paste0() 함수를 이용해 메시지를 출력한다. 만약 son == FALSE라면 else{} 함수를 이용해 “손없는 날이 아닙니다.”라는 메시지를 출력한다. find_son &lt;- function(date) { son &lt;- datatoys::Kcalendar %&gt;% filter(양력날짜 == date) %&gt;% pull(손없는날) if(son == TRUE) { message &lt;- paste0(date,&quot;은 &#39;손없는 날&#39; 입니다.&quot;) } else { message &lt;- paste0(date,&quot;은 &#39;손없는 날&#39;이 아닙니다.&quot;) } return(message) } find_son(date = &quot;2024-01-01&quot;) ## [1] &quot;2024-01-01은 &#39;손없는 날&#39; 입니다.&quot; find_son(date = &quot;2024-01-02&quot;) ## [1] &quot;2024-01-02은 &#39;손없는 날&#39;이 아닙니다.&quot; 8.1 map() 함수 R에서 반복된 작업을 수행할 때 purrr 패키지의 여러 함수들을 사용할 수 있다. purrr 패키지는 함수형 프로그래밍 패러다임을 지원하는 패키지로, map() 함수를 이용해 반복된 작업을 수행할 수 있다. map() 함수는 리스트, 벡터, 데이터프레임 등의 객체에 함수를 적용해주는 함수로, map() 함수의 첫번째 인자에는 적용할 함수를, 두번째 인자에는 적용할 객체를 입력한다. map() 함수는 for 반복문과 유사한 기능을 수행한다. map() 함수를 이용해 손없는 날인지 아닌지를 판별해보자. library(purrr) date &lt;- c(&quot;2024-01-01&quot;, &quot;2024-01-02&quot;, &quot;2024-01-03&quot;, &quot;2024-01-04&quot;, &quot;2024-01-05&quot;, &quot;2024-01-06&quot;, &quot;2024-01-07&quot;, &quot;2024-01-08&quot;, &quot;2024-01-09&quot;, &quot;2024-01-10&quot;) map(date, find_son) ## [[1]] ## [1] &quot;2024-01-01은 &#39;손없는 날&#39; 입니다.&quot; ## ## [[2]] ## [1] &quot;2024-01-02은 &#39;손없는 날&#39;이 아닙니다.&quot; ## ## [[3]] ## [1] &quot;2024-01-03은 &#39;손없는 날&#39;이 아닙니다.&quot; ## ## [[4]] ## [1] &quot;2024-01-04은 &#39;손없는 날&#39;이 아닙니다.&quot; ## ## [[5]] ## [1] &quot;2024-01-05은 &#39;손없는 날&#39;이 아닙니다.&quot; ## ## [[6]] ## [1] &quot;2024-01-06은 &#39;손없는 날&#39;이 아닙니다.&quot; ## ## [[7]] ## [1] &quot;2024-01-07은 &#39;손없는 날&#39;이 아닙니다.&quot; ## ## [[8]] ## [1] &quot;2024-01-08은 &#39;손없는 날&#39;이 아닙니다.&quot; ## ## [[9]] ## [1] &quot;2024-01-09은 &#39;손없는 날&#39;이 아닙니다.&quot; ## ## [[10]] ## [1] &quot;2024-01-10은 &#39;손없는 날&#39; 입니다.&quot; map() 함수는 기본적으로 리스트(list) 형태의 값을 반환한다. 만약 데이터프레임 형태로 값을 반환하고 싶다면 map_df() 함수를 사용한다. map_df(date, find_son) 아마도 아래와 같은 에러 메시지를 반환할 것이다. &gt; map_dfr(date, find_son) Error in `dplyr::bind_rows()`: ! Argument 1 must have names. Run `rlang::last_error()` to see where the error occurred. 이는 find_son() 함수가 데이터프레임 형태를 반환하지 않기 때문에 발생하는 에러이다. find_son() 함수를 수정해보자. find_son &lt;- function(date) { son &lt;- datatoys::Kcalendar %&gt;% filter(양력날짜 == date) %&gt;% pull(손없는날) if(son == TRUE) { message &lt;- paste0(date,&quot;은 &#39;손없는 날&#39; 입니다.&quot;) } else { message &lt;- paste0(date,&quot;은 &#39;손없는 날&#39;이 아닙니다.&quot;) } return(data.frame(date = date, message = message)) } map_df(date, find_son) ## date message ## 1 2024-01-01 2024-01-01은 &#39;손없는 날&#39; 입니다. ## 2 2024-01-02 2024-01-02은 &#39;손없는 날&#39;이 아닙니다. ## 3 2024-01-03 2024-01-03은 &#39;손없는 날&#39;이 아닙니다. ## 4 2024-01-04 2024-01-04은 &#39;손없는 날&#39;이 아닙니다. ## 5 2024-01-05 2024-01-05은 &#39;손없는 날&#39;이 아닙니다. ## 6 2024-01-06 2024-01-06은 &#39;손없는 날&#39;이 아닙니다. ## 7 2024-01-07 2024-01-07은 &#39;손없는 날&#39;이 아닙니다. ## 8 2024-01-08 2024-01-08은 &#39;손없는 날&#39;이 아닙니다. ## 9 2024-01-09 2024-01-09은 &#39;손없는 날&#39;이 아닙니다. ## 10 2024-01-10 2024-01-10은 &#39;손없는 날&#39; 입니다. "],["서울시-급똥-지도.html", "챕터 9 서울시 급똥 지도", " 챕터 9 서울시 급똥 지도 생각만해도 무시무시한 상황이 있다. 바로 ’급똥이 마려울 때’다. 이럴 때는 어떻게 해야할까? datatoys의 seoulRestroom 데이터셋을 이용해 급똥이 마려울 때 화장실을 찾아보자. 이는 서울시 공중화장실 현황정보를 제공한다. str(seoulRestroom) ## &#39;data.frame&#39;: 5046 obs. of 4 variables: ## $ 주소(구): chr &quot;송파구&quot; &quot;노원구&quot; &quot;노원구&quot; &quot;강북구&quot; ... ## $ 주소(동): chr &quot;마천동&quot; &quot;하계동&quot; &quot;하계동&quot; &quot;수유동&quot; ... ## $ 위도 : num 37.5 37.6 37.6 37.6 37.7 ... ## $ 경도 : num 127 127 127 127 127 ... 열의 이름에 괄호가 들어가 있다. 이런 경우 dplyr 패키지의 rename() 함수를 이용해 열의 이름을 변경할 수 있다. restroom &lt;- seoulRestroom %&gt;% rename( &quot;구이름&quot; = &quot;주소(구)&quot;, &quot;동이름&quot; = &quot;주소(동)&quot; ) str(restroom) ## &#39;data.frame&#39;: 5046 obs. of 4 variables: ## $ 구이름: chr &quot;송파구&quot; &quot;노원구&quot; &quot;노원구&quot; &quot;강북구&quot; ... ## $ 동이름: chr &quot;마천동&quot; &quot;하계동&quot; &quot;하계동&quot; &quot;수유동&quot; ... ## $ 위도 : num 37.5 37.6 37.6 37.6 37.7 ... ## $ 경도 : num 127 127 127 127 127 ... 또는 jonitor 패키지의 clean_names() 함수를 사용할 수도 있다. library(janitor) ## ## Attaching package: &#39;janitor&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## chisq.test, fisher.test restroom &lt;- seoulRestroom %&gt;% clean_names(ascii = FALSE) 먼저 가장 화장실에 진심인 동네를 찾아보자. restroom %&gt;% group_by(주소_구) %&gt;% summarise(화장실개수 = n()) %&gt;% arrange(desc(화장실개수)) %&gt;% head(20) ## # A tibble: 20 × 2 ## 주소_구 화장실개수 ## &lt;chr&gt; &lt;int&gt; ## 1 영등포구 835 ## 2 서초구 447 ## 3 중구 327 ## 4 송파구 275 ## 5 은평구 263 ## 6 강서구 247 ## 7 광진구 216 ## 8 성북구 205 ## 9 강남구 201 ## 10 마포구 178 ## 11 성동구 159 ## 12 강동구 157 ## 13 노원구 157 ## 14 종로구 143 ## 15 동작구 129 ## 16 양천구 126 ## 17 용산구 124 ## 18 동대문구 123 ## 19 구로구 121 ## 20 중랑구 113 restroom %&gt;% group_by(주소_구, 주소_동) %&gt;% summarise(화장실개수 = n()) %&gt;% arrange(desc(화장실개수)) %&gt;% head(20) ## `summarise()` has grouped output by &#39;주소_구&#39;. You can override using the `.groups` argument. ## # A tibble: 20 × 3 ## # Groups: 주소_구 [10] ## 주소_구 주소_동 화장실개수 ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 영등포구 여의도동 211 ## 2 서초구 서초동 198 ## 3 영등포구 영등포동 94 ## 4 영등포구 신길동 89 ## 5 서초구 방배동 82 ## 6 영등포구 양평동 75 ## 7 영등포구 대림동 73 ## 8 서초구 양재동 69 ## 9 노원구 상계동 61 ## 10 영등포구 문래동 58 ## 11 구로구 구로동 56 ## 12 도봉구 창동 49 ## 13 은평구 응암동 49 ## 14 강서구 등촌동 48 ## 15 서초구 반포동 47 ## 16 중구 신당동 47 ## 17 광진구 화양동 43 ## 18 송파구 잠실동 43 ## 19 송파구 가락동 42 ## 20 송파구 방이동 41 여의도동이 211개로 가장 많았고 서초동이 뒤를 이었다. ggplot2를 사용해 시각화 해보자. restroom %&gt;% group_by(주소_구, 주소_동) %&gt;% summarise(화장실개수 = n()) %&gt;% arrange(desc(화장실개수)) %&gt;% head(20) %&gt;% ggplot(aes(x = reorder(주소_동, 화장실개수), y = 화장실개수)) + geom_col() + geom_text(aes(label = 화장실개수), hjust = -0.) + coord_flip() + ggthemes::theme_fivethirtyeight(base_family=&quot;NanumGothic&quot;) + labs( title = &quot;급똥이 마려울 때 생존 확률이 높은 동네 TOP 20&quot;, subtitle = &quot;서울시 구별 화장실 개수&quot; ) ## `summarise()` has grouped output by &#39;주소_구&#39;. You can override using the `.groups` argument. 마지막으로 실제 서울시 화장실의 위치를 시각화해보자. library(leaflet) leaflet(seoulRestroom) %&gt;% addTiles() %&gt;% setView(lng = 126.9784, lat = 37.566, zoom = 11) %&gt;% addProviderTiles(&#39;CartoDB.Positron&#39;) %&gt;% addCircles(lng = ~경도, lat = ~위도, label = ~`주소(동)`) 보다 자세한 화장실 위치가 파악 된다. 부디 급똥이 마려울 때 이 지도를 참고해 최악의 상황을 피하길 기원한다. "],["대한민구-인구수-변화-시각화.html", "챕터 10 대한민구 인구수 변화 시각화", " 챕터 10 대한민구 인구수 변화 시각화 library(gganimate) population &lt;- datatoys::population population &lt;- subset(population, 행정구역별 != &quot;황해도&quot; &amp; 행정구역별 != &quot;평안북도&quot; &amp; 행정구역별 != &quot;평안남도&quot; &amp; 행정구역별 != &quot;함경북도&quot; &amp; 행정구역별 != &quot;함경남도&quot; &amp; 행정구역별 != &quot;함경북도&quot;) population &lt;- population %&gt;% mutate( 행정구역별 = recode(행정구역별, &quot;서울특별시&quot; = &quot;서울&quot;, &quot;부산광역시&quot; = &quot;부산&quot;, &quot;충청북도&quot; = &quot;충북&quot;, &quot;충청남도&quot; = &quot;충남&quot;, &quot;전라북도&quot; = &quot;전북&quot;, &quot;전라남도&quot; = &quot;전남&quot;, &quot;경상북도&quot; = &quot;경북&quot;, &quot;경상남도&quot; = &quot;경남&quot;, &quot;대구광역시&quot; = &quot;대구&quot;, &quot;광주광역시&quot; = &quot;광주&quot;, &quot;대전광역시&quot; = &quot;대전&quot;, &quot;울산광역시&quot; = &quot;울산&quot;, &quot;인천광역시&quot; = &quot;인천&quot;, &quot;경기도&quot; = &quot;경기&quot;, &quot;강원도&quot; = &quot;강원&quot;, &quot;제주도&quot; = &quot;제주&quot;, &quot;세종특별자치시&quot; = &quot;세종&quot;, &quot;제주특별자치도&quot; = &quot;제주&quot;) ) %&gt;% group_by(행정구역별, 연도) %&gt;% summarise( 인구수_10000 = round(sum(인구수, na.rm = TRUE) / 10000) ) %&gt;% ungroup() %&gt;% group_by(연도) %&gt;% arrange(연도, desc(인구수_10000)) %&gt;% mutate( rank = row_number(), 인구수_char = paste0(&quot; &quot;, 인구수_10000) ) %&gt;% ungroup() area_palette &lt;- c( &quot;경남&quot; = &quot;#FF65AE&quot;, &quot;경북&quot; = &quot;#FF65AE&quot;, &quot;대구&quot; = &quot;#F763E0&quot;, &quot;울산&quot; = &quot;maroon&quot;, &quot;부산&quot; = &quot;lightpink1&quot;, &quot;전남&quot; = &quot;wheat&quot;, &quot;전북&quot; = &quot;wheat&quot;, &quot;광주&quot; = &quot;tan&quot;, &quot;경기&quot; = &quot;lightblue2&quot;, &quot;서울&quot; = &quot;steelblue1&quot;, &quot;인천&quot; = &quot;turquoise&quot;, &quot;충남&quot; = &quot;gold&quot;, &quot;충북&quot; = &quot;gold&quot;, &quot;대전&quot; = &quot;yellow2&quot;, &quot;세종&quot; = &quot;goldenrod2&quot;, &quot;강원&quot; = &quot;seagreen3&quot;, &quot;제주&quot; = &quot;darkgrey&quot; ) total_population &lt;- ggplot(population, aes(rank, group = 행정구역별)) + geom_tile(aes( y = 인구수_10000 / 2, height = 인구수_10000, width = 0.9, fill = 행정구역별), alpha = 0.8) + geom_text(aes(y = 0, label = paste(행정구역별, &quot; &quot;)), vjust = 0.2, hjust = 1, size = 5, family = &quot;AppleSDGothicNeo-SemiBold&quot;) + geom_text(aes(y = 인구수_10000, label = 인구수_char, hjust = 0)) + theme_minimal(base_family = &quot;AppleSDGothicNeo-SemiBold&quot;) + theme( axis.text.x = element_text(size = 15, color = &quot;grey3&quot;, face = &quot;bold&quot;), axis.title = element_text(size = 17, color = &quot;grey21&quot;, face = &quot;bold&quot;), legend.position = &quot;none&quot;, plot.title = element_text(hjust = 0.5, size = 22, color = &quot;royalblue4&quot;, face = &quot;bold&quot;), axis.line = element_blank(), axis.text.y = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.grid.major.x = element_line(size = 0.1, color = &quot;grey&quot;), panel.grid.minor.x = element_line(size = 0.1, color = &quot;grey&quot;), plot.background = element_blank() ) + transition_states(연도, transition_length = 40, state_length = 10 ) + scale_y_continuous(breaks = seq(0, 1500, 250), labels = scales::comma) + scale_x_reverse() + scale_fill_manual(values = area_palette) + labs( title = &quot;{closest_state}년 대한민국 지역별 인구수&quot;, subtitle = &quot;1925-2021년&quot;, caption = &quot;KOSTAT; 인구총조사(통계청)&quot;, x = &quot;&quot;, y = &quot;지역별 총 인구(만명)&quot; ) + coord_flip() + ease_aes(&quot;quartic-in-out&quot;) + enter_fade() animate(plot = total_population, nframes = 400, end_pause = 20, width = 1080, height = 720) "],["울릉도의-버스정류장.html", "챕터 11 울릉도의 버스정류장", " 챕터 11 울릉도의 버스정류장 울릉도에는 버스정류장이 얼마나 있고 어디에 위치하고 있을까? datatoys의 busStation 데이터와 leaflet 패키지를 이용해 울릉도의 버스정류장을 분석해보자. busStation 데이터셋은 버스정보시스템(BIS)이 구축된 지자체 중 국가대중교통정보센터(TAGO)와 연계된 136개 지자체에 대한 버스정류장 위치정보 데이터를 제공한다. library(datatoys) library(leaflet) library(dplyr) busStation %&gt;% filter(도시명 == &quot;울릉군&quot;) %&gt;% leaflet() %&gt;% addTiles() %&gt;% addMarkers(~경도, ~위도, popup = ~as.character(정류장.명칭), label = ~as.character(정류장.명칭)) "],["statgarten.html", "챕터 12 Statgarten 12.1 CUI보다 GUI가 좋을 때 12.2 Statgarten 소개", " 챕터 12 Statgarten 12.1 CUI보다 GUI가 좋을 때 CUI의 가장 멋진 점은 대충 해도 엄청난 전문가처럼 보인다는 것이다(잘 모르는 사람이 봤을 때). 하지만 검은 화면에 커서만 깜빡거리는 CUI와 달리 GUI는 비전문가나 데이터 분석 경험이 적은 사람들에게 더 쉽고 직관적인 접근 방법을 제공한다. GUI 도구를 사용하면 더욱 편리하게 탐색적 데이터 분석을 수행할 수 있다. GUI 도구는 사용자와 상호작용하며 실시간으로 데이터를 분석할 수 있고 비 숙련자가 데이터를 원하는 방식으로 필터링하거나 조작하기 편리하다. 이를 통해 데이터의 다양한 측면을 보다 빠르고 쉽게 탐색하고 분석 결과를 동적으로 확인할 수 있다. 복잡한 분석 기법을 사용해야 하는 경우에도 GUI 도구는 사용자에게 쉽게 접근 가능한 메뉴, 버튼, 설정 등을 제공하여 분석 과정을 단순화하고 사용자의 부담을 줄일 수 있다. 12.2 Statgarten 소개 "],["나가는-말.html", "챕터 13 나가는 말", " 챕터 13 나가는 말 A sword never kills anybody. It is a tool in the killer’s hand. – Seneca 본 책과 함께한 여정을 통해 여러분이 데이터를 이해하고 데이터로 문제를 해결하는 실마리를 찾았길 바래봅니다. 한가지 당부하고 싶은 말은 부디 도구에 집착하지 말라는 것입니다. 단지 손에 좋은 도구가 들려 있다고 의미 있는 결과를 만들어 내는 것은 아닙니다. 결과를 만들어 내는 것은 최신 소프트웨어나 가장 빠른 하드웨어가 아니라, 결국 그것들을 다루는 인간의 철학과 기술입니다. 유행을 쫓기 보다는 어려운 일에 도전하세요! "]]
